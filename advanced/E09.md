# TypeScript Modules: Essential Guide

Learn how to organize and share code using TypeScript's module system with ES Modules and CommonJS.

## Table of Contents
1. [What are Modules?](#1-what-are-modules)
2. [ES Module Syntax](#2-es-module-syntax)
3. [TypeScript-Specific Features](#3-typescript-specific-features)
4. [CommonJS Interoperability](#4-commonjs-interoperability)
5. [Module Resolution & Configuration](#5-module-resolution--configuration)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Modules?

**Modules** are files that contain code with their own scope. Any file with a top-level `import` or `export` is considered a module, while files without them are treated as scripts in the global scope.

```typescript
// math.ts - This is a module (has exports)
export const PI = 3.14159;
export function add(a: number, b: number): number {
  return a + b;
}

// global.ts - This is a script (no imports/exports)
const globalVariable = "I'm in global scope";
console.log("This runs in global scope");

// Convert script to module by adding empty export
export {}; // Now it's a module with its own scope
```

**Key Benefits:**
- **Encapsulation**: Variables don't pollute global scope
- **Reusability**: Code can be imported and reused
- **Dependency Management**: Clear relationships between files
- **Tree Shaking**: Unused code can be eliminated

---

## 2. ES Module Syntax

### Default Exports
```typescript
// user.ts - Default export
export default class User {
  constructor(public name: string, public email: string) {}
  
  getInfo(): string {
    return `${this.name} <${this.email}>`;
  }
}

// Alternative default export syntax
class User {
  constructor(public name: string, public email: string) {}
}
export default User;

// Function default export
export default function createUser(name: string, email: string): User {
  return new User(name, email);
}
```

### Named Exports
```typescript
// utils.ts - Named exports
export const API_URL = "https://api.example.com";
export const MAX_RETRIES = 3;

export interface ApiResponse<T> {
  data: T;
  status: number;
  message: string;
}

export class Logger {
  static log(message: string): void {
    console.log(`[${new Date().toISOString()}] ${message}`);
  }
}

export function formatDate(date: Date): string {
  return date.toLocaleDateString();
}

// Export existing declarations
const SECRET_KEY = "abc123";
function encrypt(data: string): string {
  return btoa(data + SECRET_KEY);
}

export { SECRET_KEY, encrypt };

// Export with renaming
export { encrypt as encryptData };
```

### Import Syntax
```typescript
// app.ts - Various import patterns

// Default import
import User from "./user.js";
import createUser from "./user.js";

// Named imports
import { API_URL, Logger, formatDate } from "./utils.js";

// Import with renaming
import { API_URL as apiEndpoint, Logger as AppLogger } from "./utils.js";

// Mixed default and named imports
import User, { API_URL, Logger } from "./combined.js";

// Namespace import (import all)
import * as Utils from "./utils.js";
Utils.Logger.log("Hello");
console.log(Utils.API_URL);

// Side-effect import (runs code but doesn't import anything)
import "./polyfills.js"; // Runs polyfill code

// Usage examples
const user = new User("Alice", "alice@example.com");
Logger.log(user.getInfo());

const response = await fetch(API_URL);
console.log(formatDate(new Date()));
```

### Re-exports
```typescript
// index.ts - Barrel exports (re-exporting from multiple files)

// Re-export everything
export * from "./user.js";
export * from "./utils.js";

// Re-export specific items
export { User, createUser } from "./user.js";
export { Logger, API_URL } from "./utils.js";

// Re-export with renaming
export { Logger as AppLogger } from "./utils.js";

// Re-export default as named
export { default as User } from "./user.js";

// Mixed re-exports
export * from "./types.js";
export { default as DatabaseConnection } from "./database.js";
export { ApiClient, type ApiResponse } from "./api.js";
```

---

## 3. TypeScript-Specific Features

### Type-Only Imports and Exports
```typescript
// types.ts - Type definitions
export interface User {
  id: number;
  name: string;
  email: string;
}

export type UserRole = "admin" | "user" | "guest";

export interface ApiResponse<T> {
  data: T;
  success: boolean;
}

// functions.ts - Runtime code
export function createUser(name: string, email: string): User {
  return {
    id: Math.random(),
    name,
    email
  };
}
```

```typescript
// app.ts - Type-only imports

// Import only types (removed at compile time)
import type { User, UserRole, ApiResponse } from "./types.js";

// Import runtime values
import { createUser } from "./functions.js";

// Mixed imports with inline type annotation
import { createUser, type User, type UserRole } from "./combined.js";

// ❌ Error: Cannot use type-only import as value
// import type { createUser } from "./functions.js";
// const user = createUser("Alice", "alice@example.com"); // Error!

// ✅ Correct usage
const user: User = createUser("Alice", "alice@example.com");
const role: UserRole = "admin";

function processUsers(users: User[]): ApiResponse<User[]> {
  return {
    data: users,
    success: true
  };
}
```

### Module Augmentation
```typescript
// Extending existing modules
declare global {
  interface Window {
    myApp: {
      version: string;
      config: Record<string, any>;
    };
  }
}

// Augmenting third-party modules
declare module "express" {
  interface Request {
    user?: User;
  }
}

// Usage
window.myApp = {
  version: "1.0.0",
  config: {}
};

// In Express middleware
app.use((req, res, next) => {
  req.user = getCurrentUser(); // TypeScript knows about user property
  next();
});
```

### Ambient Modules
```typescript
// declarations.d.ts - Declare modules without implementations

// For libraries without TypeScript definitions
declare module "legacy-library" {
  export function doSomething(input: string): number;
  export const VERSION: string;
}

// For non-JS assets
declare module "*.css" {
  const classes: Record<string, string>;
  export default classes;
}

declare module "*.json" {
  const value: any;
  export default value;
}

declare module "*.svg" {
  const content: string;
  export default content;
}

// Usage
import { doSomething } from "legacy-library";
import styles from "./component.module.css";
import config from "./config.json";
import logo from "./logo.svg";
```

---

## 4. CommonJS Interoperability

### CommonJS Syntax
```typescript
// math.js - CommonJS exports
function add(a: number, b: number): number {
  return a + b;
}

function multiply(a: number, b: number): number {
  return a * b;
}

const PI = 3.14159;

// Export object
module.exports = {
  add,
  multiply,
  PI
};

// Or export individual items
exports.add = add;
exports.multiply = multiply;
exports.PI = PI;

// Default export equivalent
module.exports = add; // Single function export
```

### Importing CommonJS in TypeScript
```typescript
// Using CommonJS require syntax
import fs = require("fs");
import path = require("path");

const content = fs.readFileSync("file.txt", "utf8");
const filePath = path.join(__dirname, "data", "file.txt");

// Using ES Module syntax with CommonJS modules
import * as fs from "fs";
import * as path from "path";

// With esModuleInterop enabled
import fs from "fs"; // Works with esModuleInterop: true
import path from "path";
```

### Mixed Module Systems
```typescript
// config.ts - TypeScript configuration
interface DatabaseConfig {
  host: string;
  port: number;
  database: string;
}

interface AppConfig {
  database: DatabaseConfig;
  apiPort: number;
  environment: "development" | "production" | "test";
}

// ES Module export
export const config: AppConfig = {
  database: {
    host: process.env.DB_HOST || "localhost",
    port: parseInt(process.env.DB_PORT || "5432"),
    database: process.env.DB_NAME || "myapp"
  },
  apiPort: parseInt(process.env.PORT || "3000"),
  environment: (process.env.NODE_ENV as AppConfig["environment"]) || "development"
};

// CommonJS compatibility
export = config; // For CommonJS consumers

// Usage in CommonJS
// const config = require("./config");

// Usage in ES Modules
// import { config } from "./config.js";
// import config from "./config.js"; // With esModuleInterop
```

---

## 5. Module Resolution & Configuration

### TypeScript Configuration
```json
// tsconfig.json - Module configuration
{
  "compilerOptions": {
    "module": "ES2020",           // Output module format
    "target": "ES2020",           // JavaScript version
    "moduleResolution": "node",   // How to resolve modules
    "esModuleInterop": true,      // CommonJS/ES Module interop
    "allowSyntheticDefaultImports": true, // Allow default imports from modules with no default export
    "strict": true,
    "baseUrl": "./src",           // Base directory for relative imports
    "paths": {                    // Path mapping
      "@/*": ["*"],
      "@components/*": ["components/*"],
      "@utils/*": ["utils/*"],
      "@types/*": ["types/*"]
    },
    "rootDirs": ["src", "tests"], // Multiple root directories
    "typeRoots": ["node_modules/@types", "src/types"], // Type definition locations
    "types": ["node", "jest"]     // Include specific type packages
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
```

### Path Mapping Examples
```typescript
// With baseUrl: "./src" and paths configuration

// Instead of relative imports
import { Button } from "../../../components/ui/Button.js";
import { formatDate } from "../../utils/date.js";
import { User } from "../../../types/User.js";

// Use path mapping
import { Button } from "@components/ui/Button.js";
import { formatDate } from "@utils/date.js";
import { User } from "@types/User.js";

// Barrel exports with path mapping
// src/components/index.ts
export { Button } from "./ui/Button.js";
export { Modal } from "./ui/Modal.js";
export { Form } from "./forms/Form.js";

// Usage
import { Button, Modal, Form } from "@components";
```

### Dynamic Imports
```typescript
// Dynamic imports for code splitting
async function loadUserModule() {
  const { User, createUser } = await import("./user.js");
  return { User, createUser };
}

// Conditional loading
async function loadFeature(featureName: string) {
  switch (featureName) {
    case "charts":
      const chartModule = await import("./features/charts.js");
      return chartModule.default;
    
    case "analytics":
      const analyticsModule = await import("./features/analytics.js");
      return analyticsModule.AnalyticsService;
    
    default:
      throw new Error(`Unknown feature: ${featureName}`);
  }
}

// Usage
const feature = await loadFeature("charts");

// Type-safe dynamic imports
type ChartModule = typeof import("./features/charts.js");
type AnalyticsModule = typeof import("./features/analytics.js");

async function getChartModule(): Promise<ChartModule> {
  return import("./features/charts.js");
}
```

---

## Key Interview Questions

### Q1: What's the difference between default and named exports?
**Answer:** 
- **Default exports**: One per module, imported without braces
- **Named exports**: Multiple per module, imported with braces

```typescript
// Default export
export default class User {}
import User from "./user.js"; // No braces

// Named exports
export class User {}
export const API_URL = "...";
import { User, API_URL } from "./user.js"; // With braces
```

### Q2: What are type-only imports and why use them?
**Answer:** Type-only imports are removed at compile time and only used for type checking:

```typescript
// Type-only import (removed at runtime)
import type { User } from "./types.js";

// Regular import (included in runtime)
import { createUser } from "./functions.js";

// Benefits: Smaller bundle size, clearer intent, avoid circular dependencies
```

### Q3: How does module resolution work in TypeScript?
**Answer:** TypeScript uses two strategies:
- **Node resolution**: Mimics Node.js module resolution
- **Classic resolution**: Legacy, simpler algorithm

```typescript
// Node resolution looks for:
// 1. ./user.ts
// 2. ./user.tsx  
// 3. ./user.d.ts
// 4. ./user/index.ts
// 5. ./user/package.json (types field)

import { User } from "./user";
```

### Q4: What's the difference between `import * as` and default imports?
**Answer:**
- `import * as` creates a namespace object with all exports
- Default import gets the default export directly

```typescript
// Namespace import
import * as Utils from "./utils.js";
Utils.formatDate(); // Access via namespace

// Default import  
import formatDate from "./utils.js";
formatDate(); // Direct access
```

### Q5: How do you handle CommonJS and ES Module interoperability?
**Answer:** Use compiler options and proper import syntax:

```typescript
// tsconfig.json
{
  "esModuleInterop": true,
  "allowSyntheticDefaultImports": true
}

// Importing CommonJS modules
import fs from "fs"; // With esModuleInterop
import * as fs from "fs"; // Without esModuleInterop
import fs = require("fs"); // TypeScript-specific syntax
```

---

## Best Practices

### ✅ Do This
1. **Use ES Modules** for new projects
2. **Use type-only imports** for types to reduce bundle size
3. **Create barrel exports** for clean public APIs
4. **Use path mapping** to avoid deep relative imports
5. **Prefer named exports** over default exports for better refactoring

### ❌ Avoid This
1. **Don't mix module systems** unnecessarily
2. **Don't use `export =`** unless needed for CommonJS compatibility
3. **Don't create circular dependencies** between modules
4. **Don't put everything in one module** - keep modules focused
5. **Don't forget file extensions** in import paths (use `.js` not `.ts`)

---

## Next Steps
- **Module Bundlers**: Webpack, Rollup, Vite configuration
- **Package Development**: Creating and publishing TypeScript packages
- **Monorepos**: Managing multiple packages with shared types
- **Performance**: Optimizing module loading and tree shaking
