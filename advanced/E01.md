# TypeScript Generics: Essential Guide

Learn how to create reusable, type-safe components with generics.

## Table of Contents
1. [What are Generics?](#what-are-generics)
2. [Generic Functions](#generic-functions)
3. [Generic Constraints](#generic-constraints)
4. [Generic Interfaces and Classes](#generic-interfaces-and-classes)
5. [Advanced Generic Patterns](#advanced-generic-patterns)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Generics?

**Generics** allow you to create reusable components that work with multiple types while preserving type safety.

```typescript
// ❌ Without generics - specific type
function identityNumber(arg: number): number {
  return arg;
}

// ❌ Without generics - loses type info
function identityAny(arg: any): any {
  return arg; // Could return anything!
}

// ✅ With generics - reusable and type-safe
function identity<T>(arg: T): T {
  return arg;
}

const str = identity("hello");    // string
const num = identity(42);         // number
const bool = identity(true);      // boolean
```

**Key Benefits:**
- **Reusability**: One function works with many types
- **Type Safety**: No loss of type information
- **Better IntelliSense**: IDE knows exact types

---

## 2. Generic Functions

### Basic Generic Functions
```typescript
// Generic function with type parameter T
function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const numbers = [1, 2, 3];
const strings = ["a", "b", "c"];

const firstNum = firstElement(numbers);   // number | undefined
const firstStr = firstElement(strings);   // string | undefined
```

### Multiple Type Parameters
```typescript
function map<Input, Output>(
  arr: Input[], 
  func: (item: Input) => Output
): Output[] {
  return arr.map(func);
}

// Usage
const numbers = [1, 2, 3];
const strings = map(numbers, n => n.toString()); // string[]
const doubled = map(numbers, n => n * 2);        // number[]
```

### Type Inference vs Explicit Types
```typescript
// ✅ Type inference (preferred)
const result1 = identity("hello");        // TypeScript infers string

// ✅ Explicit type (when needed)
const result2 = identity<string>("hello"); // Explicitly specify string

// When explicit types are needed:
const emptyArray = identity<number[]>([]);  // Without <number[]>, would be never[]
```

---

## 3. Generic Constraints

Use `extends` to limit what types can be used:

### Basic Constraints
```typescript
interface Lengthwise {
  length: number;
}

function loggingIdentity<T extends Lengthwise>(arg: T): T {
  console.log(arg.length); // ✅ Now we know it has length
  return arg;
}

loggingIdentity("hello");        // ✅ string has length
loggingIdentity([1, 2, 3]);      // ✅ array has length
// loggingIdentity(42);          // ❌ number doesn't have length
```

### keyof Constraints
```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, city: "NYC" };

const name = getProperty(person, "name");     // string
const age = getProperty(person, "age");       // number
// const invalid = getProperty(person, "invalid"); // ❌ Error
```

### Conditional Constraints
```typescript
// Only allow types that can be compared
function compare<T extends string | number>(a: T, b: T): number {
  return a < b ? -1 : a > b ? 1 : 0;
}

compare("apple", "banana");  // ✅ strings
compare(10, 20);            // ✅ numbers
// compare(true, false);    // ❌ booleans not allowed
```

---

## 4. Generic Interfaces and Classes

### Generic Interfaces
```typescript
interface Container<T> {
  value: T;
  getValue(): T;
  setValue(value: T): void;
}

// Usage
const stringContainer: Container<string> = {
  value: "hello",
  getValue() { return this.value; },
  setValue(value: string) { this.value = value; }
};

const numberContainer: Container<number> = {
  value: 42,
  getValue() { return this.value; },
  setValue(value: number) { this.value = value; }
};
```

### Generic Classes
```typescript
class GenericNumber<T> {
  zeroValue: T;
  add: (x: T, y: T) => T;

  constructor(zeroValue: T, addFn: (x: T, y: T) => T) {
    this.zeroValue = zeroValue;
    this.add = addFn;
  }
}

// Usage
const myGenericNumber = new GenericNumber<number>(0, (x, y) => x + y);
myGenericNumber.zeroValue; // 0
myGenericNumber.add(5, 10); // 15

const myGenericString = new GenericNumber<string>("", (x, y) => x + y);
myGenericString.add("Hello, ", "World!"); // "Hello, World!"
```

### Generic Function Types
```typescript
// Generic function type
type GenericIdentityFn<T> = (arg: T) => T;

const myIdentity: GenericIdentityFn<number> = (x) => x;
const result = myIdentity(42); // number
```

---

## 5. Advanced Generic Patterns

### Generic Defaults
```typescript
interface ApiResponse<T = any> {
  data: T;
  status: number;
  message: string;
}

// Usage
const userResponse: ApiResponse<User> = {
  data: { name: "Alice", age: 30 },
  status: 200,
  message: "Success"
};

const genericResponse: ApiResponse = { // Uses default 'any'
  data: "anything",
  status: 200,
  message: "Success"
};
```

### Factory Functions
```typescript
function create<T>(constructor: new () => T): T {
  return new constructor();
}

class User {
  name = "Default User";
}

class Product {
  title = "Default Product";
}

const user = create(User);       // User
const product = create(Product); // Product
```

### Generic Utility Types
```typescript
// Custom utility types
type Partial<T> = {
  [P in keyof T]?: T[P];
};

type Pick<T, K extends keyof T> = {
  [P in K]: T[P];
};

// Usage
interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

type PartialUser = Partial<User>;        // All properties optional
type UserSummary = Pick<User, "name" | "email">; // Only name and email
```

---

## Key Interview Questions

### Q1: What are generics and why are they useful?
**Answer:** Generics allow creating reusable components that work with multiple types while preserving type safety. They solve the problem of having to choose between type safety and reusability.

```typescript
// Without generics: choose between specific types or any
function identityString(arg: string): string { return arg; }
function identityAny(arg: any): any { return arg; } // Loses type info

// With generics: both reusable and type-safe
function identity<T>(arg: T): T { return arg; }
```

### Q2: How do generic constraints work?
**Answer:** Generic constraints use `extends` to limit what types can be used with a generic:

```typescript
// Constrain T to types with length property
function logLength<T extends { length: number }>(arg: T): T {
  console.log(arg.length);
  return arg;
}

logLength("hello");     // ✅ string has length
logLength([1, 2, 3]);   // ✅ array has length
// logLength(42);       // ❌ number doesn't have length
```

### Q3: What's the difference between generic functions and generic interfaces?
**Answer:**
- **Generic functions**: Type parameters are specified when calling the function
- **Generic interfaces**: Type parameters are specified when using the interface

```typescript
// Generic function - T specified at call time
function process<T>(value: T): T { return value; }
const result = process<string>("hello");

// Generic interface - T specified when using interface
interface Container<T> {
  value: T;
}
const container: Container<string> = { value: "hello" };
```

### Q4: How do you use keyof with generics?
**Answer:** `keyof` creates a union of all property names, useful for type-safe property access:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age");   // number
```

### Q5: When should you use generic defaults?
**Answer:** Use generic defaults when you have a sensible fallback type:

```typescript
interface ApiResponse<T = unknown> {
  data: T;
  success: boolean;
}

// Can specify type
const userResponse: ApiResponse<User> = { data: user, success: true };

// Or use default
const response: ApiResponse = { data: anything, success: true };
```

---

## Best Practices

### ✅ Do This
1. **Use meaningful type parameter names** (`T` for single type, `K` for keys, `V` for values)
2. **Prefer type inference** over explicit type arguments when possible
3. **Use constraints** to make generics more specific and safe
4. **Use generic defaults** for common use cases
5. **Keep generics simple** - don't over-engineer

### ❌ Avoid This
1. **Don't use generics unnecessarily** - if you only need one type, don't use generics
2. **Don't create overly complex constraints** - keep them understandable
3. **Don't use `any` in generic contexts** - defeats the purpose
4. **Don't ignore type inference** - let TypeScript do the work
5. **Don't create too many type parameters** - usually 1-3 is enough

---

## Next Steps
- **Keyof Operator**: Advanced key manipulation
- **Conditional Types**: Type-level if statements
- **Mapped Types**: Transform existing types
- **Template Literal Types**: String manipulation at type level
