# TypeScript Conditional Types: Essential Guide

Learn how to create type-level if statements for dynamic type logic.

## Table of Contents
1. [What are Conditional Types?](#what-are-conditional-types)
2. [Basic Conditional Types](#basic-conditional-types)
3. [Conditional Types with Generics](#conditional-types-with-generics)
4. [The infer Keyword](#the-infer-keyword)
5. [Distributive Conditional Types](#distributive-conditional-types)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Conditional Types?

**Conditional Types** are TypeScript's way of creating type-level if statements. They use the `extends` keyword to test type relationships and return different types based on the result.

```typescript
// Basic syntax: T extends U ? X : Y
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<string>;  // true
type Test2 = IsString<number>;  // false
type Test3 = IsString<"hello">; // true
```

**Real-world example:**
```typescript
interface Animal {
  live(): void;
}

interface Dog extends Animal {
  woof(): void;
}

// Check if Dog extends Animal
type Example1 = Dog extends Animal ? "Yes" : "No";     // "Yes"
type Example2 = RegExp extends Animal ? "Yes" : "No";  // "No"
```

---

## 2. Basic Conditional Types

### Simple Type Checking
```typescript
// Check if type is an array
type IsArray<T> = T extends any[] ? true : false;

type Test1 = IsArray<string[]>;   // true
type Test2 = IsArray<number>;     // false
type Test3 = IsArray<boolean[]>;  // true

// Check if type is a function
type IsFunction<T> = T extends (...args: any[]) => any ? true : false;

type Test4 = IsFunction<() => void>;        // true
type Test5 = IsFunction<string>;            // false
type Test6 = IsFunction<(x: number) => string>; // true
```

### Type Filtering
```typescript
// Remove null and undefined from a type
type NonNullable<T> = T extends null | undefined ? never : T;

type Test1 = NonNullable<string | null>;      // string
type Test2 = NonNullable<number | undefined>; // number
type Test3 = NonNullable<boolean | null | undefined>; // boolean
```

### Default Type Assignment
```typescript
// Provide default types
type DefaultTo<T, Default> = T extends undefined ? Default : T;

type Test1 = DefaultTo<string, "default">;    // string
type Test2 = DefaultTo<undefined, "default">; // "default"
type Test3 = DefaultTo<number, 0>;            // number
```

---

## 3. Conditional Types with Generics

### Replacing Function Overloads
```typescript
// Instead of multiple overloads:
// function createLabel(id: number): IdLabel;
// function createLabel(name: string): NameLabel;

interface IdLabel {
  id: number;
}

interface NameLabel {
  name: string;
}

// Use conditional type
type LabelType<T extends number | string> = T extends number
  ? IdLabel
  : NameLabel;

function createLabel<T extends number | string>(idOrName: T): LabelType<T> {
  throw "unimplemented";
}

const a = createLabel("typescript");  // NameLabel
const b = createLabel(2.8);          // IdLabel
const c = createLabel(Math.random() ? "hello" : 42); // NameLabel | IdLabel
```

### Property Extraction with Fallback
```typescript
// Extract message property if it exists, otherwise return never
type MessageOf<T> = T extends { message: unknown } ? T["message"] : never;

interface Email {
  message: string;
}

interface Dog {
  bark(): void;
}

type EmailMessage = MessageOf<Email>; // string
type DogMessage = MessageOf<Dog>;     // never
```

### Array Flattening
```typescript
// Flatten array types, leave others unchanged
type Flatten<T> = T extends any[] ? T[number] : T;

type Test1 = Flatten<string[]>;  // string
type Test2 = Flatten<number>;    // number
type Test3 = Flatten<boolean[]>; // boolean
```

---

## 4. The infer Keyword

The `infer` keyword lets you extract and capture types within conditional types.

### Basic infer Usage
```typescript
// Extract array element type
type ArrayElement<T> = T extends (infer U)[] ? U : never;

type Test1 = ArrayElement<string[]>;   // string
type Test2 = ArrayElement<number[]>;   // number
type Test3 = ArrayElement<boolean>;    // never
```

### Function Return Type Extraction
```typescript
// Extract function return type
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type Test1 = GetReturnType<() => string>;           // string
type Test2 = GetReturnType<(x: number) => boolean>; // boolean
type Test3 = GetReturnType<string>;                 // never
```

### Function Parameter Extraction
```typescript
// Extract first parameter type
type FirstParameter<T> = T extends (first: infer P, ...args: any[]) => any ? P : never;

type Test1 = FirstParameter<(name: string, age: number) => void>; // string
type Test2 = FirstParameter<(id: number) => string>;              // number
type Test3 = FirstParameter<() => void>;                          // never

// Extract all parameters as tuple
type Parameters<T> = T extends (...args: infer P) => any ? P : never;

type Test4 = Parameters<(a: string, b: number) => void>; // [string, number]
type Test5 = Parameters<() => void>;                     // []
```

### Promise Value Extraction
```typescript
// Extract Promise value type
type Awaited<T> = T extends Promise<infer U> ? U : T;

type Test1 = Awaited<Promise<string>>;  // string
type Test2 = Awaited<Promise<number>>;  // number
type Test3 = Awaited<string>;           // string (not a Promise)

// Handle nested Promises
type DeepAwaited<T> = T extends Promise<infer U> 
  ? DeepAwaited<U> 
  : T;

type Test4 = DeepAwaited<Promise<Promise<string>>>; // string
```

### Object Property Extraction
```typescript
// Extract property types by key pattern
type GetterReturnType<T> = T extends { [K in keyof T]: T[K] } 
  ? T[K] extends () => infer R 
    ? R 
    : never 
  : never;

interface User {
  getName(): string;
  getAge(): number;
  email: string;
}

// This is complex - simpler approach:
type ExtractGetter<T, K extends keyof T> = T[K] extends () => infer R ? R : never;

type NameType = ExtractGetter<User, "getName">; // string
type AgeType = ExtractGetter<User, "getAge">;   // number
type EmailType = ExtractGetter<User, "email">;  // never (not a function)
```

---

## 5. Distributive Conditional Types

Conditional types distribute over union types by default.

### Basic Distribution
```typescript
// This distributes over union types
type ToArray<T> = T extends any ? T[] : never;

type Test1 = ToArray<string | number>; // string[] | number[]

// Equivalent to:
// ToArray<string> | ToArray<number>
// which becomes: string[] | number[]
```

### Filtering Union Types
```typescript
// Remove specific types from union
type Exclude<T, U> = T extends U ? never : T;

type Test1 = Exclude<"a" | "b" | "c", "a">;        // "b" | "c"
type Test2 = Exclude<string | number | boolean, string>; // number | boolean

// Extract specific types from union
type Extract<T, U> = T extends U ? T : never;

type Test3 = Extract<"a" | "b" | "c", "a" | "b">;  // "a" | "b"
type Test4 = Extract<string | number | boolean, string>; // string
```

### Non-Distributive Conditional Types
```typescript
// Prevent distribution with brackets
type ToArrayNonDist<T> = [T] extends [any] ? T[] : never;

type Test1 = ToArrayNonDist<string | number>; // (string | number)[]
// NOT string[] | number[]

// Practical example: tuple from union
type UnionToTuple<T> = [T] extends [any] ? [T] : never;

type Test2 = UnionToTuple<"a" | "b">; // ["a" | "b"]
```

### Real-World Distribution Examples
```typescript
// Make all properties optional that are of certain type
type PartialBy<T, K extends keyof T> = Omit<T, K> & Partial<Pick<T, K>>;

interface User {
  id: string;
  name: string;
  email: string;
  age: number;
}

type UserWithOptionalStrings = PartialBy<User, "name" | "email">;
// Result: { id: string; age: number; name?: string; email?: string; }

// Filter object properties by type
type StringProperties<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

type UserStringProps = StringProperties<User>; // "id" | "name" | "email"
```

---

## Key Interview Questions

### Q1: What are conditional types and how do they work?
**Answer:** Conditional types are TypeScript's type-level if statements that use the `extends` keyword to test type relationships:

```typescript
type IsString<T> = T extends string ? true : false;

type Test1 = IsString<"hello">; // true
type Test2 = IsString<number>;  // false
```

### Q2: What is the `infer` keyword and when do you use it?
**Answer:** `infer` lets you extract and capture types within conditional types:

```typescript
// Extract return type from function
type GetReturnType<T> = T extends (...args: any[]) => infer R ? R : never;

type Test = GetReturnType<() => string>; // string
```

### Q3: What are distributive conditional types?
**Answer:** Conditional types automatically distribute over union types:

```typescript
type ToArray<T> = T extends any ? T[] : never;

type Test = ToArray<string | number>; // string[] | number[]
// Distributes to: ToArray<string> | ToArray<number>
```

### Q4: How do you prevent distribution in conditional types?
**Answer:** Wrap both sides of `extends` in brackets:

```typescript
// Distributive (default)
type Dist<T> = T extends any ? T[] : never;
type Test1 = Dist<string | number>; // string[] | number[]

// Non-distributive
type NonDist<T> = [T] extends [any] ? T[] : never;
type Test2 = NonDist<string | number>; // (string | number)[]
```

### Q5: How do you use conditional types to replace function overloads?
**Answer:** Create a conditional type that returns different types based on input:

```typescript
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : T extends number 
  ? { id: T } 
  : never;

function createResponse<T extends string | number>(input: T): ApiResponse<T> {
  // Implementation
}

const stringResponse = createResponse("hello"); // { message: string }
const numberResponse = createResponse(42);      // { id: number }
```

---

## Best Practices

### ✅ Do This
1. **Use conditional types** to replace complex function overloads
2. **Use `infer`** to extract types from complex type structures
3. **Understand distribution** - it usually helps but sometimes needs to be prevented
4. **Combine with other advanced types** like mapped types and template literals
5. **Use meaningful names** for inferred types (not just `T`, `U`)

### ❌ Avoid This
1. **Don't over-complicate** - sometimes simple types are better
2. **Don't nest too deeply** - keep conditional types readable
3. **Don't forget about distribution** when working with unions
4. **Don't use conditional types unnecessarily** - use them when you need dynamic behavior
5. **Don't ignore the `never` type** - it's useful for filtering

---

## Next Steps
- **Mapped Types**: Transform all properties of a type systematically
- **Template Literal Types**: Advanced string manipulation at type level
- **Utility Types**: Built-in TypeScript helpers that use conditional types
- **Advanced Type Patterns**: Combining all advanced type features
