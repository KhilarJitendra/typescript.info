# TypeScript keyof Operator: Essential Guide

Learn how to extract and work with object keys at the type level.

## Table of Contents
1. [What is keyof?](#what-is-keyof)
2. [Basic keyof Usage](#basic-keyof-usage)
3. [keyof with Index Signatures](#keyof-with-index-signatures)
4. [Practical Applications](#practical-applications)
5. [Advanced Patterns](#advanced-patterns)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What is keyof?

The `keyof` operator extracts the keys of an object type as a union of string/number literals.

```typescript
type Person = {
  name: string;
  age: number;
  email: string;
};

type PersonKeys = keyof Person; // "name" | "age" | "email"

// Usage
function getPersonProperty(person: Person, key: PersonKeys) {
  return person[key]; // Type-safe property access
}

const person = { name: "Alice", age: 30, email: "alice@example.com" };
const name = getPersonProperty(person, "name");     // ✅ Valid
const age = getPersonProperty(person, "age");       // ✅ Valid
// const invalid = getPersonProperty(person, "invalid"); // ❌ Error
```

---

## 2. Basic keyof Usage

### Simple Object Types
```typescript
type Point = { x: number; y: number };
type PointKeys = keyof Point; // "x" | "y"

type User = {
  id: string;
  name: string;
  isActive: boolean;
};
type UserKeys = keyof User; // "id" | "name" | "isActive"
```

### With Functions and Methods
```typescript
type Calculator = {
  add(a: number, b: number): number;
  subtract(a: number, b: number): number;
  value: number;
};

type CalculatorKeys = keyof Calculator; // "add" | "subtract" | "value"
```

### Type-Safe Property Access
```typescript
function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const user = { name: "Alice", age: 30, active: true };

const name = getValue(user, "name");     // string
const age = getValue(user, "age");       // number
const active = getValue(user, "active"); // boolean
```

---

## 3. keyof with Index Signatures

### Number Index Signatures
```typescript
type ArrayLike = { [n: number]: string };
type ArrayKeys = keyof ArrayLike; // number

const arrayLike: ArrayLike = ["a", "b", "c"];
// Can access with numbers: arrayLike[0], arrayLike[1], etc.
```

### String Index Signatures
```typescript
type StringMap = { [k: string]: boolean };
type StringMapKeys = keyof StringMap; // string | number

// Why string | number?
// Because obj[0] is the same as obj["0"] in JavaScript
const map: StringMap = { "0": true, "key": false };
console.log(map[0]);     // Same as map["0"]
console.log(map["key"]); // Direct string access
```

### Mixed Properties and Index Signatures
```typescript
type MixedType = {
  name: string;
  age: number;
  [key: string]: string | number; // Index signature
};

type MixedKeys = keyof MixedType; // string | number
// All properties must be compatible with the index signature
```

---

## 4. Practical Applications

### Type-Safe Object Manipulation
```typescript
function pick<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result = {} as Pick<T, K>;
  for (const key of keys) {
    result[key] = obj[key];
  }
  return result;
}

const user = { id: "1", name: "Alice", email: "alice@example.com", age: 30 };
const summary = pick(user, ["name", "email"]); // { name: string; email: string; }
```

### Dynamic Property Updates
```typescript
function updateProperty<T, K extends keyof T>(
  obj: T, 
  key: K, 
  value: T[K]
): T {
  return { ...obj, [key]: value };
}

const user = { name: "Alice", age: 30 };
const updatedUser = updateProperty(user, "age", 31);     // ✅ Valid
// const invalid = updateProperty(user, "age", "thirty"); // ❌ Error: string not assignable to number
```

### Form Field Validation
```typescript
type FormData = {
  username: string;
  email: string;
  password: string;
};

type FormErrors = {
  [K in keyof FormData]?: string; // Optional error for each field
};

function validateForm(data: FormData): FormErrors {
  const errors: FormErrors = {};
  
  if (!data.username) errors.username = "Username is required";
  if (!data.email.includes("@")) errors.email = "Invalid email";
  if (data.password.length < 8) errors.password = "Password too short";
  
  return errors;
}
```

---

## 5. Advanced Patterns

### Nested keyof
```typescript
type User = {
  profile: {
    name: string;
    avatar: string;
  };
  settings: {
    theme: "light" | "dark";
    notifications: boolean;
  };
};

type UserKeys = keyof User; // "profile" | "settings"
type ProfileKeys = keyof User["profile"]; // "name" | "avatar"
type SettingsKeys = keyof User["settings"]; // "theme" | "notifications"

// Deep property access
function getNestedValue<T, K1 extends keyof T, K2 extends keyof T[K1]>(
  obj: T,
  key1: K1,
  key2: K2
): T[K1][K2] {
  return obj[key1][key2];
}

const user: User = {
  profile: { name: "Alice", avatar: "avatar.jpg" },
  settings: { theme: "dark", notifications: true }
};

const name = getNestedValue(user, "profile", "name");       // string
const theme = getNestedValue(user, "settings", "theme");    // "light" | "dark"
```

### Conditional keyof
```typescript
// Get keys of properties that are functions
type FunctionPropertyNames<T> = {
  [K in keyof T]: T[K] extends Function ? K : never;
}[keyof T];

type Calculator = {
  value: number;
  add: (x: number) => number;
  multiply: (x: number) => number;
  reset: () => void;
};

type CalculatorMethods = FunctionPropertyNames<Calculator>; // "add" | "multiply" | "reset"
```

### keyof with Template Literals
```typescript
type EventMap = {
  click: MouseEvent;
  keydown: KeyboardEvent;
  focus: FocusEvent;
};

type EventKeys = keyof EventMap; // "click" | "keydown" | "focus"

// Create handler names
type EventHandlers = {
  [K in keyof EventMap as `on${Capitalize<K>}`]: (event: EventMap[K]) => void;
};

// Result:
// {
//   onClick: (event: MouseEvent) => void;
//   onKeydown: (event: KeyboardEvent) => void;
//   onFocus: (event: FocusEvent) => void;
// }
```

---

## Key Interview Questions

### Q1: What does the keyof operator do?
**Answer:** `keyof` extracts the keys of an object type as a union of string/number literals:

```typescript
type Person = { name: string; age: number };
type PersonKeys = keyof Person; // "name" | "age"
```

### Q2: Why does keyof with string index signatures return string | number?
**Answer:** Because JavaScript coerces numeric keys to strings, so `obj[0]` is the same as `obj["0"]`:

```typescript
type StringMap = { [k: string]: any };
type Keys = keyof StringMap; // string | number

const map: StringMap = {};
map[0] = "value";     // Same as map["0"] = "value"
map["0"] = "value";   // Same as above
```

### Q3: How do you create a type-safe property getter function?
**Answer:** Use keyof with generic constraints:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

// Usage ensures type safety
const user = { name: "Alice", age: 30 };
const name = getProperty(user, "name"); // string
const age = getProperty(user, "age");   // number
```

### Q4: How does keyof work with optional properties?
**Answer:** `keyof` includes all properties, whether required or optional:

```typescript
type User = {
  name: string;
  email?: string; // Optional
};

type UserKeys = keyof User; // "name" | "email"

// But T[K] will be string | undefined for optional properties
function getValue<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key]; // Could be undefined for optional properties
}
```

### Q5: How do you filter keys by property type?
**Answer:** Use mapped types with conditional types:

```typescript
type StringPropertyNames<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

type User = {
  name: string;    // string
  age: number;     // number
  email: string;   // string
};

type StringKeys = StringPropertyNames<User>; // "name" | "email"
```

---

## Best Practices

### ✅ Do This
1. **Use keyof with generic constraints** for type-safe property access
2. **Combine keyof with mapped types** for powerful transformations
3. **Use keyof for dynamic property operations** like pick/omit utilities
4. **Remember that keyof includes all properties** (required and optional)
5. **Use keyof with template literals** for advanced string manipulation

### ❌ Avoid This
1. **Don't assume keyof only returns strings** - can include numbers and symbols
2. **Don't forget about index signatures** affecting keyof results
3. **Don't use keyof unnecessarily** - sometimes explicit unions are clearer
4. **Don't ignore optional property implications** when using T[K]
5. **Don't overcomplicate** - keep keyof usage readable and maintainable

---

## Next Steps
- **Typeof Operator**: Extract types from values
- **Indexed Access Types**: Access nested type properties
- **Mapped Types**: Transform object types systematically
- **Template Literal Types**: Advanced string manipulation at type level
