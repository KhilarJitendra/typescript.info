# TypeScript typeof Operator: Essential Guide

Learn how to extract types from values using the typeof operator.

## Table of Contents
1. [What is typeof in Types?](#what-is-typeof-in-types)
2. [Basic typeof Usage](#basic-typeof-usage)
3. [typeof with Functions](#typeof-with-functions)
4. [typeof with Objects and Classes](#typeof-with-objects-and-classes)
5. [Practical Applications](#practical-applications)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What is typeof in Types?

TypeScript has two `typeof` operators:
- **Runtime `typeof`**: JavaScript operator that returns a string
- **Type-level `typeof`**: TypeScript operator that extracts the type of a value

```typescript
// Runtime typeof (JavaScript)
const message = "hello";
console.log(typeof message); // Prints: "string"

// Type-level typeof (TypeScript)
let anotherMessage: typeof message; // Type: string
anotherMessage = "world"; // ✅ Valid
// anotherMessage = 42;   // ❌ Error: number not assignable to string
```

**Key Difference:**
- Runtime `typeof` is used in expressions and returns strings
- Type-level `typeof` is used in type positions and extracts actual TypeScript types

---

## 2. Basic typeof Usage

### Extracting Variable Types
```typescript
const userName = "Alice";
const userAge = 30;
const isActive = true;

// Extract types from existing variables
type UserName = typeof userName; // string
type UserAge = typeof userAge;   // number
type IsActive = typeof isActive; // boolean

// Use extracted types
let newUserName: UserName = "Bob";     // ✅ string
let newUserAge: UserAge = 25;          // ✅ number
let newIsActive: IsActive = false;     // ✅ boolean
```

### typeof with Complex Values
```typescript
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000,
  retries: 3,
  features: {
    darkMode: true,
    notifications: false
  }
};

type Config = typeof config;
// Type: {
//   apiUrl: string;
//   timeout: number;
//   retries: number;
//   features: {
//     darkMode: boolean;
//     notifications: boolean;
//   };
// }

// Create new config with same structure
const devConfig: Config = {
  apiUrl: "https://dev-api.example.com",
  timeout: 10000,
  retries: 5,
  features: {
    darkMode: false,
    notifications: true
  }
};
```

---

## 3. typeof with Functions

### Function Type Extraction
```typescript
function greet(name: string, age: number): string {
  return `Hello ${name}, you are ${age} years old`;
}

type GreetFunction = typeof greet;
// Type: (name: string, age: number) => string

// Use the extracted function type
const customGreet: GreetFunction = (name, age) => {
  return `Hi ${name}! Age: ${age}`;
};
```

### ReturnType with typeof
```typescript
function createUser() {
  return {
    id: Math.random().toString(),
    name: "Default User",
    createdAt: new Date(),
    isActive: true
  };
}

// ❌ This doesn't work - f is a value, not a type
// type User = ReturnType<createUser>;

// ✅ Use typeof to get the function type first
type User = ReturnType<typeof createUser>;
// Type: {
//   id: string;
//   name: string;
//   createdAt: Date;
//   isActive: boolean;
// }

// Now we can use the User type
const newUser: User = {
  id: "user-123",
  name: "Alice",
  createdAt: new Date(),
  isActive: true
};
```

### Parameters with typeof
```typescript
function processOrder(orderId: string, items: string[], priority: "low" | "high") {
  // Process order logic
}

type ProcessOrderParams = Parameters<typeof processOrder>;
// Type: [orderId: string, items: string[], priority: "low" | "high"]

// Use the extracted parameter types
function logOrderProcessing(...args: ProcessOrderParams) {
  const [orderId, items, priority] = args;
  console.log(`Processing order ${orderId} with ${items.length} items (${priority} priority)`);
}
```

---

## 4. typeof with Objects and Classes

### Object Type Extraction
```typescript
const theme = {
  colors: {
    primary: "#007bff",
    secondary: "#6c757d",
    success: "#28a745"
  },
  spacing: {
    small: "8px",
    medium: "16px",
    large: "24px"
  },
  breakpoints: ["768px", "1024px", "1200px"] as const
};

type Theme = typeof theme;

// Create variations of the theme
const darkTheme: Theme = {
  colors: {
    primary: "#0d6efd",
    secondary: "#6c757d",
    success: "#198754"
  },
  spacing: {
    small: "8px",
    medium: "16px",
    large: "24px"
  },
  breakpoints: ["768px", "1024px", "1200px"]
};
```

### Class Constructor Types
```typescript
class User {
  constructor(public name: string, public email: string) {}
  
  greet() {
    return `Hello, I'm ${this.name}`;
  }
}

// Get the constructor type
type UserConstructor = typeof User;
// Type: new (name: string, email: string) => User

// Get the instance type
type UserInstance = InstanceType<typeof User>;
// Type: User

// Factory function using constructor type
function createUser(UserClass: UserConstructor, name: string, email: string) {
  return new UserClass(name, email);
}

const user = createUser(User, "Alice", "alice@example.com");
```

---

## 5. Practical Applications

### Configuration Type Safety
```typescript
const defaultConfig = {
  database: {
    host: "localhost",
    port: 5432,
    name: "myapp"
  },
  server: {
    port: 3000,
    cors: true
  },
  features: {
    auth: true,
    analytics: false
  }
} as const;

type AppConfig = typeof defaultConfig;

// Ensure all environments use the same config structure
const productionConfig: AppConfig = {
  database: {
    host: "prod-db.example.com",
    port: 5432,
    name: "myapp_prod"
  },
  server: {
    port: 80,
    cors: false
  },
  features: {
    auth: true,
    analytics: true
  }
};
```

### API Response Type Extraction
```typescript
// Mock API response
const mockUserResponse = {
  data: {
    id: "user-123",
    profile: {
      name: "Alice",
      avatar: "avatar.jpg"
    },
    preferences: {
      theme: "dark" as const,
      notifications: true
    }
  },
  meta: {
    timestamp: "2023-01-01T00:00:00Z",
    version: "1.0"
  }
};

type UserResponse = typeof mockUserResponse;

// Type-safe API client
async function fetchUser(id: string): Promise<UserResponse> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}
```

### Utility Type Creation
```typescript
const validators = {
  email: (value: string) => value.includes("@"),
  minLength: (min: number) => (value: string) => value.length >= min,
  required: (value: any) => value != null && value !== ""
};

type Validators = typeof validators;
type ValidatorKeys = keyof Validators;
// Type: "email" | "minLength" | "required"

// Create form validation system
function createValidator<T extends Record<string, any>>(
  schema: { [K in keyof T]: ValidatorKeys[] }
) {
  return (data: T) => {
    const errors: Partial<Record<keyof T, string>> = {};
    
    for (const field in schema) {
      const fieldValidators = schema[field];
      for (const validatorKey of fieldValidators) {
        const validator = validators[validatorKey];
        // Validation logic here
      }
    }
    
    return errors;
  };
}
```

---

## Key Interview Questions

### Q1: What's the difference between runtime typeof and type-level typeof?
**Answer:** 
- **Runtime `typeof`**: JavaScript operator used in expressions, returns strings like "string", "number"
- **Type-level `typeof`**: TypeScript operator used in type positions, extracts actual TypeScript types

```typescript
const value = "hello";

// Runtime typeof
console.log(typeof value); // Prints: "string"

// Type-level typeof
type ValueType = typeof value; // Type: string
```

### Q2: Why do you need typeof with ReturnType?
**Answer:** Because `ReturnType` expects a function type, not a function value:

```typescript
function getUser() {
  return { name: "Alice", age: 30 };
}

// ❌ Error: 'getUser' refers to a value, not a type
// type User = ReturnType<getUser>;

// ✅ Correct: Use typeof to get the function type
type User = ReturnType<typeof getUser>;
```

### Q3: What are the limitations of typeof?
**Answer:** `typeof` can only be used on identifiers (variable names) and their properties, not on arbitrary expressions:

```typescript
const obj = { name: "Alice" };

// ✅ Valid - identifier
type ObjType = typeof obj;

// ✅ Valid - property access
type NameType = typeof obj.name;

// ❌ Invalid - function call expression
// type ResultType = typeof someFunction();
```

### Q4: How do you extract constructor types from classes?
**Answer:** Use `typeof` on the class name to get the constructor type:

```typescript
class User {
  constructor(public name: string) {}
}

type UserConstructor = typeof User;        // Constructor type
type UserInstance = InstanceType<typeof User>; // Instance type

function createUser(UserClass: UserConstructor, name: string) {
  return new UserClass(name);
}
```

### Q5: How does typeof work with const assertions?
**Answer:** `typeof` preserves the exact literal types created by `as const`:

```typescript
const config = {
  theme: "dark",
  version: 1
} as const;

type Config = typeof config;
// Type: { readonly theme: "dark"; readonly version: 1; }

// Without as const:
const config2 = {
  theme: "dark",
  version: 1
};

type Config2 = typeof config2;
// Type: { theme: string; version: number; }
```

---

## Best Practices

### ✅ Do This
1. **Use typeof to extract types from existing values** for consistency
2. **Combine typeof with utility types** like `ReturnType` and `Parameters`
3. **Use typeof with const assertions** to preserve literal types
4. **Extract configuration types** to ensure consistency across environments
5. **Use typeof for class constructor types** in factory patterns

### ❌ Avoid This
1. **Don't use typeof on function calls** - only on identifiers and properties
2. **Don't confuse runtime and type-level typeof** - they serve different purposes
3. **Don't overuse typeof** - sometimes explicit types are clearer
4. **Don't forget const assertions** when you need literal types
5. **Don't use typeof unnecessarily** - for simple types, explicit typing is often better

---

## Next Steps
- **Indexed Access Types**: Access nested type properties with `T[K]`
- **Conditional Types**: Type-level if statements
- **Mapped Types**: Transform object types systematically
- **Template Literal Types**: Advanced string manipulation at type level
