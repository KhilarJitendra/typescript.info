# TypeScript Template Literal Types: Essential Guide

Learn how to manipulate and generate string types dynamically using template literal syntax.

## Table of Contents

1. [What are Template Literal Types?](#1-what-are-template-literal-types)
2. [Basic String Interpolation](#2-basic-string-interpolation)
3. [Union Cross-Multiplication](#3-union-cross-multiplication)
4. [Advanced Type Inference](#4-advanced-type-inference)
5. [Intrinsic String Manipulation](#5-intrinsic-string-manipulation)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Template Literal Types?

**Template Literal Types** use JavaScript's template literal syntax in type positions to create new string literal types by combining and manipulating existing types.

```typescript
// Basic template literal type
type World = "world";
type Greeting = `hello ${World}`; // "hello world"

// With unions - creates all combinations
type Status = "loading" | "success" | "error";
type Message = `Status: ${Status}`;
// Result: "Status: loading" | "Status: success" | "Status: error"
```

**Key Benefits:**

- **Dynamic String Generation**: Create string types programmatically
- **Type Safety**: Ensure string patterns are followed correctly
- **API Design**: Build strongly-typed string-based APIs

---

## 2. Basic String Interpolation

### Simple Concatenation

```typescript
// Basic string building
type Protocol = "https";
type Domain = "api.example.com";
type ApiUrl = `${Protocol}://${Domain}`; // "https://api.example.com"

// With literal values
type Version = "v1";
type Endpoint = "users";
type FullPath = `/${Version}/${Endpoint}`; // "/v1/users"
```

### Building Configuration Keys

```typescript
// Environment-based configuration
type Environment = "dev" | "staging" | "prod";
type Service = "api" | "db" | "cache";

type ConfigKey = `${Environment}_${Service}_url`;
// Result: "dev_api_url" | "dev_db_url" | "dev_cache_url" |
//         "staging_api_url" | "staging_db_url" | "staging_cache_url" |
//         "prod_api_url" | "prod_db_url" | "prod_cache_url"

// Usage in configuration object
type Config = {
  [K in ConfigKey]: string;
};

const config: Config = {
  dev_api_url: "http://localhost:3000",
  dev_db_url: "mongodb://localhost:27017",
  dev_cache_url: "redis://localhost:6379",
  // ... all other combinations required
};
```

### CSS Class Generation

```typescript
// BEM methodology class names
type Block = "button" | "card" | "modal";
type Element = "header" | "body" | "footer";
type Modifier = "primary" | "secondary" | "disabled";

type BEMClass = `${Block}__${Element}--${Modifier}`;
// Result: "button__header--primary" | "button__header--secondary" | ... (27 combinations)

// Simplified version for specific use
type ButtonClass = `button--${Modifier}`;
// Result: "button--primary" | "button--secondary" | "button--disabled"
```

---

## 3. Union Cross-Multiplication

### Event Name Generation

```typescript
// Generate event names from actions and entities
type Action = "create" | "update" | "delete";
type Entity = "user" | "post" | "comment";

type EventName = `${Action}_${Entity}`;
// Result: "create_user" | "create_post" | "create_comment" |
//         "update_user" | "update_post" | "update_comment" |
//         "delete_user" | "delete_post" | "delete_comment"

// Event handler type
type EventHandlers = {
  [K in EventName]: (data: any) => void;
};

const handlers: EventHandlers = {
  create_user: (userData) => console.log("User created", userData),
  create_post: (postData) => console.log("Post created", postData),
  // ... all other handlers required
};
```

### Localization Keys

```typescript
// Multi-language support
type Language = "en" | "es" | "fr";
type Section = "header" | "footer" | "sidebar";
type MessageType = "title" | "description" | "button";

type LocaleKey = `${Language}.${Section}.${MessageType}`;
// Result: "en.header.title" | "en.header.description" | "en.header.button" |
//         "es.header.title" | ... (27 combinations)

// Translation object
type Translations = {
  [K in LocaleKey]: string;
};

const translations: Partial<Translations> = {
  "en.header.title": "Welcome",
  "en.header.description": "This is the header",
  "es.header.title": "Bienvenido",
  // ...
};
```

### API Route Generation

```typescript
// RESTful API routes
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";
type Resource = "users" | "posts" | "comments";
type RoutePattern =
  | `${HttpMethod} /${Resource}`
  | `${HttpMethod} /${Resource}/:id`;

// Result includes: "GET /users" | "POST /users" | "PUT /users" | "DELETE /users" |
//                  "GET /users/:id" | "POST /users/:id" | "PUT /users/:id" | "DELETE /users/:id" |
//                  ... (same for posts and comments)

type ApiRoutes = {
  [K in RoutePattern]: (req: any, res: any) => void;
};
```

---

## 4. Advanced Type Inference

### Property Change Events

```typescript
// Watch object property changes
type PropEventSource<T> = {
  on<K extends string & keyof T>(
    eventName: `${K}Changed`,
    callback: (newValue: T[K]) => void
  ): void;
};

declare function makeWatchedObject<T>(obj: T): T & PropEventSource<T>;

const person = makeWatchedObject({
  firstName: "Alice",
  lastName: "Smith",
  age: 30,
});

// Type-safe event listening
person.on("firstNameChanged", (newName) => {
  // newName is inferred as string
  console.log(`Name changed to ${newName.toUpperCase()}`);
});

person.on("ageChanged", (newAge) => {
  // newAge is inferred as number
  if (newAge < 0) console.warn("Invalid age");
});

// ❌ Errors for invalid event names
// person.on("firstName", () => {}); // Error: should be "firstNameChanged"
// person.on("invalidChanged", () => {}); // Error: no such property
```

### Form Field Validation

```typescript
// Generate validation function names from form fields
type FormData = {
  email: string;
  password: string;
  confirmPassword: string;
  age: number;
};

type ValidationFunctions = {
  [K in keyof FormData as `validate${Capitalize<string & K>}`]: (
    value: FormData[K]
  ) => boolean;
};

const validators: ValidationFunctions = {
  validateEmail: (email: string) => email.includes("@"),
  validatePassword: (password: string) => password.length >= 8,
  validateConfirmPassword: (confirmPassword: string) => true, // Would check against password
  validateAge: (age: number) => age >= 18,
};

// Usage with type inference
function validateField<K extends keyof FormData>(
  field: K,
  value: FormData[K]
): boolean {
  const validatorName = `validate${
    field.charAt(0).toUpperCase() + field.slice(1)
  }` as keyof ValidationFunctions;
  return validators[validatorName](value);
}
```

### Database Query Builder

```typescript
// Type-safe query builder
type User = {
  id: number;
  name: string;
  email: string;
  age: number;
};

type QueryMethods<T> = {
  [K in keyof T as `findBy${Capitalize<string & K>}`]: (
    value: T[K]
  ) => Promise<T[]>;
} & {
  [K in keyof T as `updateBy${Capitalize<string & K>}`]: (
    value: T[K],
    updates: Partial<T>
  ) => Promise<T>;
};

declare const userRepository: QueryMethods<User>;

// Type-safe usage
const usersByName = await userRepository.findByName("Alice"); // Promise<User[]>
const usersByAge = await userRepository.findByAge(25); // Promise<User[]>
const updatedUser = await userRepository.updateById(1, { name: "Bob" }); // Promise<User>
```

---

## 5. Intrinsic String Manipulation

### Built-in String Utilities

```typescript
// Uppercase - converts entire string to uppercase
type Greeting = "hello, world";
type ShoutyGreeting = Uppercase<Greeting>; // "HELLO, WORLD"

// Lowercase - converts entire string to lowercase
type QuietGreeting = Lowercase<Greeting>; // "hello, world"

// Capitalize - converts first character to uppercase
type LowercaseGreeting = "hello, world";
type CapitalizedGreeting = Capitalize<LowercaseGreeting>; // "Hello, world"

// Uncapitalize - converts first character to lowercase
type UppercaseGreeting = "HELLO WORLD";
type UncapitalizedGreeting = Uncapitalize<UppercaseGreeting>; // "hELLO WORLD"
```

### Practical Applications

```typescript
// Generate getter/setter method names
type CreateAccessors<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
} & {
  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => void;
};

type User = {
  name: string;
  age: number;
};

type UserAccessors = CreateAccessors<User>;
// Result: {
//   getName: () => string;
//   getAge: () => number;
//   setName: (value: string) => void;
//   setAge: (value: number) => void;
// }

// CSS custom property names
type CSSVariables<T extends Record<string, any>> = {
  [K in keyof T as `--${Lowercase<string & K>}`]: string;
};

type ThemeColors = {
  PRIMARY: string;
  SECONDARY: string;
  BACKGROUND: string;
};

type CSSTheme = CSSVariables<ThemeColors>;
// Result: {
//   "--primary": string;
//   "--secondary": string;
//   "--background": string;
// }
```

### Environment Variable Types

```typescript
// Generate environment variable names
type EnvConfig = {
  apiUrl: string;
  dbHost: string;
  redisPort: number;
};

type EnvVars = {
  [K in keyof EnvConfig as `${Uppercase<string & K>}`]: string;
};

// Result: { APIURL: string; DBHOST: string; REDISPORT: string; }

// More realistic with prefix
type PrefixedEnvVars<T, Prefix extends string> = {
  [K in keyof T as `${Prefix}_${Uppercase<string & K>}`]: string;
};

type AppEnvVars = PrefixedEnvVars<EnvConfig, "APP">;
// Result: { APP_APIURL: string; APP_DBHOST: string; APP_REDISPORT: string; }
```

### Command Generation

```typescript
// CLI command generation
type Commands = {
  build: { target: string };
  test: { coverage: boolean };
  deploy: { environment: string };
};

type CLICommands = {
  [K in keyof Commands as `run${Capitalize<string & K>}`]: (
    options: Commands[K]
  ) => void;
};

const cli: CLICommands = {
  runBuild: (options) => console.log(`Building ${options.target}`),
  runTest: (options) =>
    console.log(`Testing with coverage: ${options.coverage}`),
  runDeploy: (options) => console.log(`Deploying to ${options.environment}`),
};
```

---

## Key Interview Questions

### Q1: What are template literal types and how do they work?

**Answer:** Template literal types use JavaScript's template literal syntax in type positions to create new string literal types:

```typescript
type World = "world";
type Greeting = `hello ${World}`; // "hello world"

// With unions - creates all combinations
type Status = "success" | "error";
type Message = `Status: ${Status}`; // "Status: success" | "Status: error"
```

### Q2: How do template literal types handle union cross-multiplication?

**Answer:** When unions are used in interpolated positions, TypeScript creates every possible combination:

```typescript
type Action = "create" | "update";
type Entity = "user" | "post";
type Event = `${Action}_${Entity}`;
// Result: "create_user" | "create_post" | "update_user" | "update_post"
```

### Q3: What are the built-in string manipulation utilities?

**Answer:** TypeScript provides four intrinsic string manipulation types:

```typescript
type Example = "hello world";

type Upper = Uppercase<Example>; // "HELLO WORLD"
type Lower = Lowercase<Example>; // "hello world"
type Cap = Capitalize<Example>; // "Hello world"
type Uncap = Uncapitalize<"HELLO">; // "hELLO"
```

### Q4: How do you use template literal types for type-safe event handling?

**Answer:** Combine template literals with generic constraints and indexed access:

```typescript
type PropEventSource<T> = {
  on<K extends string & keyof T>(
    eventName: `${K}Changed`,
    callback: (newValue: T[K]) => void
  ): void;
};

// Usage ensures type safety
person.on("nameChanged", (newName: string) => {}); // ✅ string inferred
person.on("ageChanged", (newAge: number) => {}); // ✅ number inferred
```

### Q5: When should you avoid template literal types?

**Answer:** Avoid them when they create too many combinations or hurt performance:

```typescript
// ❌ This creates 1000+ combinations - too many!
type BadExample = `${string}_${string}_${string}`;

// ✅ Better: Use specific unions or generate ahead of time
type GoodExample = `user_${"create" | "update" | "delete"}`;

// For large combinations, consider code generation instead of compile-time types
```

---

## Best Practices

### ✅ Do This

1. **Use template literals** for string pattern enforcement
2. **Combine with mapped types** for systematic transformations
3. **Leverage intrinsic utilities** for case transformations
4. **Keep union sizes reasonable** to avoid performance issues
5. **Use generic constraints** for type-safe inference

### ❌ Avoid This

1. **Don't create massive unions** - they slow compilation
2. **Don't use `string` in templates** - it creates infinite types
3. **Don't over-complicate** - sometimes simple strings are better
4. **Don't forget the `string &` trick** when using `keyof` in templates
5. **Don't ignore performance** - profile large template literal types

---

## Next Steps

- **Utility Types**: Built-in TypeScript helpers that use template literals
- **Advanced Type Patterns**: Combining all advanced type features
- **Performance Optimization**: Writing efficient template literal types
- **Real-World Applications**: Building type-safe APIs and libraries
