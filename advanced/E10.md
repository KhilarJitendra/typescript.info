# TypeScript Declaration Files (.d.ts): Essential Guide

Learn how to create and use TypeScript declaration files to add type information to JavaScript libraries and projects.

## Table of Contents
1. [What are Declaration Files?](#what-are-declaration-files)
2. [Basic Declaration Syntax](#basic-declaration-syntax)
3. [Module Declarations](#module-declarations)
4. [Advanced Declaration Patterns](#advanced-declaration-patterns)
5. [Publishing & Distribution](#publishing--distribution)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Declaration Files?

**Declaration files (.d.ts)** provide type information for JavaScript code without containing any implementation. They act as a bridge between TypeScript and JavaScript libraries.

```typescript
// math.js - JavaScript library
function add(a, b) {
  return a + b;
}

function multiply(a, b) {
  return a * b;
}

module.exports = { add, multiply };
```

```typescript
// math.d.ts - Declaration file
export function add(a: number, b: number): number;
export function multiply(a: number, b: number): number;
```

```typescript
// app.ts - TypeScript usage with type safety
import { add, multiply } from './math';

const result1 = add(5, 3);        // ✅ number
const result2 = multiply(4, 2);   // ✅ number
// const result3 = add("5", 3);   // ❌ Error: string not assignable to number
```

**Key Benefits:**
- **Type Safety**: Add types to existing JavaScript libraries
- **IntelliSense**: Get autocomplete and documentation
- **Gradual Migration**: Incrementally add types to JS projects
- **Library Integration**: Use untyped libraries with TypeScript

---

## 2. Basic Declaration Syntax

### Variable Declarations
```typescript
// globals.d.ts - Global variable declarations
declare var API_URL: string;
declare let currentUser: User | null;
declare const VERSION: string;

// Environment variables
declare namespace NodeJS {
  interface ProcessEnv {
    NODE_ENV: 'development' | 'production' | 'test';
    API_URL: string;
    DATABASE_URL: string;
    JWT_SECRET: string;
  }
}

// Usage in TypeScript
console.log(API_URL);           // ✅ string
console.log(process.env.NODE_ENV); // ✅ 'development' | 'production' | 'test'
```

### Function Declarations
```typescript
// utils.d.ts - Function declarations
declare function formatDate(date: Date): string;
declare function parseJSON<T>(json: string): T;
declare function debounce<T extends (...args: any[]) => any>(
  func: T,
  wait: number
): T;

// Overloaded functions
declare function createElement(tagName: 'div'): HTMLDivElement;
declare function createElement(tagName: 'span'): HTMLSpanElement;
declare function createElement(tagName: string): HTMLElement;

// Usage
const formattedDate = formatDate(new Date()); // ✅ string
const data = parseJSON<User>('{"name": "Alice"}'); // ✅ User
const div = createElement('div'); // ✅ HTMLDivElement
```

### Class Declarations
```typescript
// logger.d.ts - Class declarations
declare class Logger {
  constructor(name: string);
  
  // Properties
  readonly name: string;
  level: 'debug' | 'info' | 'warn' | 'error';
  
  // Methods
  debug(message: string, ...args: any[]): void;
  info(message: string, ...args: any[]): void;
  warn(message: string, ...args: any[]): void;
  error(message: string, ...args: any[]): void;
  
  // Static methods
  static create(name: string): Logger;
  static getLogger(name: string): Logger;
}

// Usage
const logger = new Logger('app');
logger.info('Application started'); // ✅ void
const staticLogger = Logger.create('static'); // ✅ Logger
```

### Interface and Type Declarations
```typescript
// types.d.ts - Interface and type declarations
interface User {
  id: number;
  name: string;
  email: string;
  roles: Role[];
}

interface Role {
  id: number;
  name: string;
  permissions: Permission[];
}

interface Permission {
  id: number;
  action: string;
  resource: string;
}

type UserRole = 'admin' | 'user' | 'guest';
type ApiResponse<T> = {
  data: T;
  status: number;
  message: string;
};

// Generic constraints
type EventHandler<T extends Event> = (event: T) => void;
type KeysOfType<T, U> = {
  [K in keyof T]: T[K] extends U ? K : never;
}[keyof T];
```

---

## 3. Module Declarations

### ES Module Declarations
```typescript
// api-client.d.ts - ES Module declarations
export interface ApiClient {
  get<T>(url: string): Promise<T>;
  post<T>(url: string, data: any): Promise<T>;
  put<T>(url: string, data: any): Promise<T>;
  delete(url: string): Promise<void>;
}

export interface RequestConfig {
  baseURL?: string;
  timeout?: number;
  headers?: Record<string, string>;
}

export declare class HttpClient implements ApiClient {
  constructor(config?: RequestConfig);
  get<T>(url: string): Promise<T>;
  post<T>(url: string, data: any): Promise<T>;
  put<T>(url: string, data: any): Promise<T>;
  delete(url: string): Promise<void>;
}

export declare function createClient(config?: RequestConfig): ApiClient;

// Default export
declare const client: ApiClient;
export default client;
```

### CommonJS Module Declarations
```typescript
// lodash.d.ts - CommonJS module declarations
declare namespace _ {
  interface LoDashStatic {
    // Array methods
    chunk<T>(array: T[], size?: number): T[][];
    compact<T>(array: (T | null | undefined | false | "" | 0)[]): T[];
    flatten<T>(array: T[][]): T[];
    
    // Object methods
    pick<T, K extends keyof T>(object: T, ...keys: K[]): Pick<T, K>;
    omit<T, K extends keyof T>(object: T, ...keys: K[]): Omit<T, K>;
    
    // Collection methods
    map<T, R>(collection: T[], iteratee: (value: T, index: number) => R): R[];
    filter<T>(collection: T[], predicate: (value: T) => boolean): T[];
    
    // Utility methods
    debounce<T extends (...args: any[]) => any>(func: T, wait: number): T;
    throttle<T extends (...args: any[]) => any>(func: T, wait: number): T;
  }
}

declare const _: _.LoDashStatic;
export = _;

// Usage
import * as _ from 'lodash';
const chunked = _.chunk([1, 2, 3, 4], 2); // ✅ number[][]
```

### Ambient Module Declarations
```typescript
// declarations.d.ts - Ambient module declarations

// For libraries without type definitions
declare module 'legacy-library' {
  export interface Config {
    apiKey: string;
    endpoint: string;
  }
  
  export class Client {
    constructor(config: Config);
    request(method: string, path: string): Promise<any>;
  }
  
  export function initialize(config: Config): Client;
}

// For asset imports
declare module '*.css' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.scss' {
  const classes: { [key: string]: string };
  export default classes;
}

declare module '*.json' {
  const value: any;
  export default value;
}

declare module '*.svg' {
  const content: any;
  export default content;
}

declare module '*.png' {
  const src: string;
  export default src;
}

// Usage
import { Client, initialize } from 'legacy-library';
import styles from './component.module.css';
import config from './config.json';
import logo from './logo.svg';
```

### Global Augmentation
```typescript
// global-augmentation.d.ts - Extending global objects

// Extend Window interface
declare global {
  interface Window {
    gtag: (
      command: 'config' | 'event',
      targetId: string,
      config?: Record<string, any>
    ) => void;
    
    dataLayer: any[];
    
    myApp: {
      version: string;
      config: AppConfig;
      utils: AppUtils;
    };
  }
  
  // Extend Array prototype
  interface Array<T> {
    last(): T | undefined;
    first(): T | undefined;
  }
  
  // Extend String prototype
  interface String {
    toTitleCase(): string;
    truncate(length: number): string;
  }
}

// Module augmentation for third-party libraries
declare module 'express' {
  interface Request {
    user?: User;
    session?: Session;
  }
  
  interface Response {
    success(data: any): void;
    error(message: string, code?: number): void;
  }
}

declare module 'react' {
  interface CSSProperties {
    '--custom-property'?: string;
  }
}

// Usage
window.gtag('event', 'page_view'); // ✅ Valid
const lastItem = [1, 2, 3].last(); // ✅ number | undefined
const title = "hello world".toTitleCase(); // ✅ string

// In Express middleware
app.use((req, res, next) => {
  req.user = getCurrentUser(); // ✅ User | undefined
  res.success({ message: 'OK' }); // ✅ void
});
```

---

## 4. Advanced Declaration Patterns

### Conditional Types in Declarations
```typescript
// advanced-types.d.ts - Advanced type patterns

// Utility types for API responses
type ApiResult<T> = T extends string 
  ? { message: T } 
  : T extends number 
  ? { id: T } 
  : { data: T };

// Function overloads with conditional return types
declare function processData<T>(input: T): ApiResult<T>;

// Mapped types for form validation
type ValidationRules<T> = {
  [K in keyof T]?: {
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    pattern?: RegExp;
    custom?: (value: T[K]) => boolean;
  };
};

declare function createValidator<T>(rules: ValidationRules<T>): (data: T) => boolean;

// Template literal types for event names
type EventMap = {
  user: { id: number; name: string };
  order: { id: string; total: number };
  product: { sku: string; name: string };
};

type EventName<T extends keyof EventMap> = `${T}:${string}`;

declare class EventEmitter {
  on<T extends keyof EventMap>(
    event: EventName<T>,
    handler: (data: EventMap[T]) => void
  ): void;
  
  emit<T extends keyof EventMap>(
    event: EventName<T>,
    data: EventMap[T]
  ): void;
}
```

### Plugin System Declarations
```typescript
// plugin-system.d.ts - Extensible plugin system

interface PluginContext {
  app: Application;
  config: Record<string, any>;
  logger: Logger;
}

interface Plugin {
  name: string;
  version: string;
  install(context: PluginContext): void | Promise<void>;
  uninstall?(context: PluginContext): void | Promise<void>;
}

// Plugin registry with type safety
interface PluginRegistry {
  auth: AuthPlugin;
  database: DatabasePlugin;
  cache: CachePlugin;
}

interface AuthPlugin extends Plugin {
  authenticate(token: string): Promise<User | null>;
  authorize(user: User, resource: string): boolean;
}

interface DatabasePlugin extends Plugin {
  connect(url: string): Promise<void>;
  query<T>(sql: string, params?: any[]): Promise<T[]>;
  transaction<T>(callback: () => Promise<T>): Promise<T>;
}

interface CachePlugin extends Plugin {
  get<T>(key: string): Promise<T | null>;
  set<T>(key: string, value: T, ttl?: number): Promise<void>;
  delete(key: string): Promise<void>;
}

declare class Application {
  use<K extends keyof PluginRegistry>(
    name: K,
    plugin: PluginRegistry[K]
  ): void;
  
  getPlugin<K extends keyof PluginRegistry>(name: K): PluginRegistry[K];
}
```

### React Component Declarations
```typescript
// react-components.d.ts - React component type declarations

import { ComponentType, ReactNode, CSSProperties } from 'react';

// Component props with variants
interface ButtonProps {
  children: ReactNode;
  variant?: 'primary' | 'secondary' | 'danger';
  size?: 'small' | 'medium' | 'large';
  disabled?: boolean;
  loading?: boolean;
  onClick?: (event: MouseEvent) => void;
}

declare const Button: ComponentType<ButtonProps>;

// Generic component props
interface DataTableProps<T> {
  data: T[];
  columns: Array<{
    key: keyof T;
    title: string;
    render?: (value: T[keyof T], record: T) => ReactNode;
  }>;
  onRowClick?: (record: T) => void;
  loading?: boolean;
  pagination?: {
    page: number;
    pageSize: number;
    total: number;
    onChange: (page: number, pageSize: number) => void;
  };
}

declare function DataTable<T extends Record<string, any>>(
  props: DataTableProps<T>
): JSX.Element;

// Higher-order component declarations
interface WithLoadingProps {
  loading?: boolean;
}

declare function withLoading<P extends object>(
  Component: ComponentType<P>
): ComponentType<P & WithLoadingProps>;

// Hook declarations
interface UseApiResult<T> {
  data: T | null;
  loading: boolean;
  error: Error | null;
  refetch: () => Promise<void>;
}

declare function useApi<T>(url: string): UseApiResult<T>;
declare function useLocalStorage<T>(
  key: string,
  defaultValue: T
): [T, (value: T) => void];
```

---

## 5. Publishing & Distribution

### Package.json Configuration
```json
{
  "name": "my-typescript-library",
  "version": "1.0.0",
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": [
    "dist/**/*"
  ],
  "scripts": {
    "build": "tsc",
    "prepublishOnly": "npm run build"
  },
  "devDependencies": {
    "typescript": "^4.9.0"
  },
  "typesVersions": {
    ">=4.0": {
      "*": ["dist/*"]
    },
    ">=3.8": {
      "*": ["dist-legacy/*"]
    }
  }
}
```

### TSConfig for Declaration Generation
```json
// tsconfig.json - Configuration for generating declarations
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "CommonJS",
    "lib": ["ES2020", "DOM"],
    "outDir": "./dist",
    "rootDir": "./src",
    
    // Declaration file generation
    "declaration": true,
    "declarationMap": true,
    "declarationDir": "./dist",
    
    // Bundling declarations
    "declarationMap": true,
    
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist", "**/*.test.ts"]
}
```

### Library Structure
```
my-library/
├── src/
│   ├── index.ts
│   ├── utils/
│   │   ├── index.ts
│   │   └── helpers.ts
│   └── types/
│       ├── index.ts
│       └── api.ts
├── dist/
│   ├── index.js
│   ├── index.d.ts
│   ├── utils/
│   │   ├── index.js
│   │   ├── index.d.ts
│   │   ├── helpers.js
│   │   └── helpers.d.ts
│   └── types/
│       ├── index.js
│       ├── index.d.ts
│       ├── api.js
│       └── api.d.ts
├── package.json
└── tsconfig.json
```

### DefinitelyTyped Contribution
```typescript
// @types/example-library/index.d.ts - DefinitelyTyped format

// Type definitions for example-library 1.2
// Project: https://github.com/example/example-library
// Definitions by: Your Name <https://github.com/yourusername>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

export interface Config {
  apiKey: string;
  baseURL: string;
  timeout?: number;
}

export class Client {
  constructor(config: Config);
  request<T>(method: string, url: string, data?: any): Promise<T>;
}

export function createClient(config: Config): Client;

// Augment global namespace if library adds globals
declare global {
  namespace ExampleLibrary {
    interface GlobalConfig extends Config {
      debug?: boolean;
    }
  }
}
```

---

## Key Interview Questions

### Q1: What are TypeScript declaration files and when do you use them?
**Answer:** Declaration files (.d.ts) provide type information for JavaScript code without implementation:

```typescript
// JavaScript library (math.js)
function add(a, b) { return a + b; }

// Declaration file (math.d.ts)
export function add(a: number, b: number): number;

// TypeScript usage with type safety
import { add } from './math';
const result = add(5, 3); // ✅ number
```

**Use cases**: Adding types to JS libraries, gradual migration, third-party library integration.

### Q2: How do you declare global variables and extend global objects?
**Answer:** Use `declare global` for global augmentation:

```typescript
declare global {
  interface Window {
    myApp: { version: string };
  }
  
  var API_URL: string;
}

// Usage
window.myApp.version; // ✅ string
console.log(API_URL); // ✅ string
```

### Q3: What's the difference between `declare module` and `declare namespace`?
**Answer:**
- `declare module`: For external modules (files with imports/exports)
- `declare namespace`: For global namespaces or internal organization

```typescript
// External module
declare module 'library-name' {
  export function doSomething(): void;
}

// Global namespace
declare namespace MyLibrary {
  interface Config {
    apiKey: string;
  }
}
```

### Q4: How do you handle module augmentation for third-party libraries?
**Answer:** Use module augmentation to extend existing module interfaces:

```typescript
declare module 'express' {
  interface Request {
    user?: User;
  }
}

declare module 'react' {
  interface CSSProperties {
    '--custom-var'?: string;
  }
}

// Now TypeScript knows about these extensions
app.use((req, res) => {
  req.user = getCurrentUser(); // ✅ Works
});
```

### Q5: How do you publish a TypeScript library with proper type definitions?
**Answer:** Configure package.json and tsconfig.json properly:

```json
// package.json
{
  "main": "dist/index.js",
  "types": "dist/index.d.ts",
  "files": ["dist/**/*"]
}

// tsconfig.json
{
  "compilerOptions": {
    "declaration": true,
    "declarationMap": true,
    "outDir": "./dist"
  }
}
```

---

## Best Practices

### ✅ Do This
1. **Use `declare` for ambient declarations** without implementation
2. **Organize types logically** in separate declaration files
3. **Use module augmentation** to extend third-party libraries safely
4. **Include declaration maps** for better debugging experience
5. **Document your types** with JSDoc comments

### ❌ Avoid This
1. **Don't mix implementation and declarations** in .d.ts files
2. **Don't use `any` excessively** - provide specific types when possible
3. **Don't forget to export types** that consumers need
4. **Don't create overly complex type hierarchies** - keep it maintainable
5. **Don't ignore version compatibility** when publishing types

---

## Next Steps
- **Advanced Type Manipulation**: Conditional types, mapped types in declarations
- **Library Design**: Creating well-typed APIs and plugin systems
- **Performance**: Optimizing declaration file size and compilation speed
- **Tooling**: Using tools like API Extractor for better declaration management
