# TypeScript Classes: Essential Guide

Learn how to use classes in TypeScript with type safety, inheritance, and advanced features.

## Table of Contents
1. [Basic Class Structure](#1-basic-class-structure)
2. [Class Members & Visibility](#2-class-members--visibility)
3. [Inheritance & Polymorphism](#3-inheritance--polymorphism)
4. [Advanced Class Features](#4-advanced-class-features)
5. [Key Interview Questions](#key-interview-questions)

---

## 1. Basic Class Structure

### Fields and Constructors
```typescript
class User {
  // Field declarations with types
  name: string;
  age: number;
  email: string;
  
  // Fields with initializers
  isActive: boolean = true;
  createdAt: Date = new Date();
  
  constructor(name: string, age: number, email: string) {
    this.name = name;
    this.age = age;
    this.email = email;
  }
  
  // Methods
  getInfo(): string {
    return `${this.name} (${this.age}) - ${this.email}`;
  }
  
  updateEmail(newEmail: string): void {
    this.email = newEmail;
  }
}

const user = new User("Alice", 30, "alice@example.com");
console.log(user.getInfo()); // "Alice (30) - alice@example.com"
```

### Parameter Properties (Shorthand)
```typescript
// Instead of verbose field declarations
class UserVerbose {
  name: string;
  age: number;
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// Use parameter properties for cleaner code
class User {
  constructor(
    public name: string,
    public age: number,
    private id: string = Math.random().toString(),
    readonly createdAt: Date = new Date()
  ) {}
  
  getInfo(): string {
    return `${this.name} (${this.age})`;
  }
}

const user = new User("Bob", 25);
console.log(user.name); // "Bob" - accessible (public)
// console.log(user.id); // Error - private
console.log(user.createdAt); // Date - readonly, can't be changed
```

### Getters and Setters
```typescript
class Temperature {
  private _celsius: number = 0;
  
  // Getter
  get celsius(): number {
    return this._celsius;
  }
  
  // Setter with validation
  set celsius(value: number) {
    if (value < -273.15) {
      throw new Error("Temperature cannot be below absolute zero");
    }
    this._celsius = value;
  }
  
  // Computed property
  get fahrenheit(): number {
    return (this._celsius * 9/5) + 32;
  }
  
  set fahrenheit(value: number) {
    this.celsius = (value - 32) * 5/9;
  }
}

const temp = new Temperature();
temp.celsius = 25;
console.log(temp.fahrenheit); // 77
temp.fahrenheit = 100;
console.log(temp.celsius); // 37.77...
```

---

## 2. Class Members & Visibility

### Visibility Modifiers
```typescript
class BankAccount {
  public accountNumber: string;     // Accessible everywhere
  protected balance: number;        // Accessible in class and subclasses
  private pin: string;             // Only accessible within this class
  readonly accountType: string;    // Cannot be modified after initialization
  
  constructor(accountNumber: string, initialBalance: number, pin: string) {
    this.accountNumber = accountNumber;
    this.balance = initialBalance;
    this.pin = pin;
    this.accountType = "Checking";
  }
  
  // Public method
  public getBalance(): number {
    return this.balance;
  }
  
  // Protected method - available to subclasses
  protected validatePin(inputPin: string): boolean {
    return this.pin === inputPin;
  }
  
  // Private method - only within this class
  private logTransaction(amount: number, type: string): void {
    console.log(`${type}: $${amount} on ${new Date()}`);
  }
  
  public withdraw(amount: number, pin: string): boolean {
    if (!this.validatePin(pin)) {
      return false;
    }
    
    if (amount <= this.balance) {
      this.balance -= amount;
      this.logTransaction(amount, "Withdrawal");
      return true;
    }
    return false;
  }
}

class SavingsAccount extends BankAccount {
  private interestRate: number;
  
  constructor(accountNumber: string, initialBalance: number, pin: string, interestRate: number) {
    super(accountNumber, initialBalance, pin);
    this.interestRate = interestRate;
  }
  
  public addInterest(): void {
    // Can access protected balance from parent
    const interest = this.balance * this.interestRate;
    this.balance += interest;
    
    // Can call protected method from parent
    console.log(`Interest added. New balance: $${this.getBalance()}`);
  }
  
  // Cannot access private pin or logTransaction from parent
}

const account = new BankAccount("123456", 1000, "1234");
console.log(account.accountNumber); // ✅ Public - accessible
console.log(account.getBalance());  // ✅ Public method
// console.log(account.balance);    // ❌ Error - protected
// console.log(account.pin);        // ❌ Error - private
```

### Static Members
```typescript
class MathUtils {
  static readonly PI = 3.14159;
  static readonly E = 2.71828;
  
  // Static method
  static circleArea(radius: number): number {
    return MathUtils.PI * radius * radius;
  }
  
  static randomBetween(min: number, max: number): number {
    return Math.random() * (max - min) + min;
  }
  
  // Instance method can access static members
  calculateCircumference(radius: number): number {
    return 2 * MathUtils.PI * radius;
  }
}

// Access static members without instantiation
console.log(MathUtils.PI);                    // 3.14159
console.log(MathUtils.circleArea(5));         // 78.54
console.log(MathUtils.randomBetween(1, 10));  // Random number 1-10

// Can still create instances for instance methods
const utils = new MathUtils();
console.log(utils.calculateCircumference(5)); // 31.416
```

---

## 3. Inheritance & Polymorphism

### Basic Inheritance
```typescript
// Base class
abstract class Animal {
  protected name: string;
  protected age: number;
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
  
  // Concrete method
  getInfo(): string {
    return `${this.name} is ${this.age} years old`;
  }
  
  // Abstract method - must be implemented by subclasses
  abstract makeSound(): string;
  abstract move(): string;
}

class Dog extends Animal {
  private breed: string;
  
  constructor(name: string, age: number, breed: string) {
    super(name, age); // Call parent constructor
    this.breed = breed;
  }
  
  // Implement abstract methods
  makeSound(): string {
    return "Woof! Woof!";
  }
  
  move(): string {
    return `${this.name} runs on four legs`;
  }
  
  // Additional method specific to Dog
  fetch(): string {
    return `${this.name} fetches the ball`;
  }
  
  // Override parent method
  getInfo(): string {
    return `${super.getInfo()} and is a ${this.breed}`;
  }
}

class Bird extends Animal {
  private canFly: boolean;
  
  constructor(name: string, age: number, canFly: boolean = true) {
    super(name, age);
    this.canFly = canFly;
  }
  
  makeSound(): string {
    return "Tweet! Tweet!";
  }
  
  move(): string {
    return this.canFly ? `${this.name} flies` : `${this.name} walks`;
  }
}

// Usage
const dog = new Dog("Buddy", 3, "Golden Retriever");
const bird = new Bird("Tweety", 1);

console.log(dog.getInfo());    // "Buddy is 3 years old and is a Golden Retriever"
console.log(dog.makeSound());  // "Woof! Woof!"
console.log(dog.fetch());      // "Buddy fetches the ball"

console.log(bird.makeSound()); // "Tweet! Tweet!"
console.log(bird.move());      // "Tweety flies"

// Polymorphism - treat different types uniformly
const animals: Animal[] = [dog, bird];
animals.forEach(animal => {
  console.log(animal.getInfo());
  console.log(animal.makeSound());
});
```

### Interface Implementation
```typescript
interface Flyable {
  altitude: number;
  fly(): void;
  land(): void;
}

interface Swimmable {
  depth: number;
  swim(): void;
  surface(): void;
}

// Class can implement multiple interfaces
class Duck extends Animal implements Flyable, Swimmable {
  altitude: number = 0;
  depth: number = 0;
  
  constructor(name: string, age: number) {
    super(name, age);
  }
  
  makeSound(): string {
    return "Quack! Quack!";
  }
  
  move(): string {
    if (this.altitude > 0) return `${this.name} is flying at ${this.altitude}ft`;
    if (this.depth > 0) return `${this.name} is swimming at ${this.depth}ft deep`;
    return `${this.name} is walking`;
  }
  
  // Implement Flyable
  fly(): void {
    this.altitude = 100;
    this.depth = 0;
  }
  
  land(): void {
    this.altitude = 0;
  }
  
  // Implement Swimmable
  swim(): void {
    this.depth = 5;
    this.altitude = 0;
  }
  
  surface(): void {
    this.depth = 0;
  }
}

const duck = new Duck("Donald", 2);
duck.fly();
console.log(duck.move()); // "Donald is flying at 100ft"
duck.swim();
console.log(duck.move()); // "Donald is swimming at 5ft deep"
```

---

## 4. Advanced Class Features

### Generic Classes
```typescript
class Container<T> {
  private items: T[] = [];
  
  add(item: T): void {
    this.items.push(item);
  }
  
  get(index: number): T | undefined {
    return this.items[index];
  }
  
  getAll(): T[] {
    return [...this.items]; // Return copy
  }
  
  find(predicate: (item: T) => boolean): T | undefined {
    return this.items.find(predicate);
  }
  
  filter(predicate: (item: T) => boolean): T[] {
    return this.items.filter(predicate);
  }
  
  get length(): number {
    return this.items.length;
  }
}

// Usage with different types
const numberContainer = new Container<number>();
numberContainer.add(1);
numberContainer.add(2);
numberContainer.add(3);

const stringContainer = new Container<string>();
stringContainer.add("hello");
stringContainer.add("world");

interface User {
  id: number;
  name: string;
  email: string;
}

const userContainer = new Container<User>();
userContainer.add({ id: 1, name: "Alice", email: "alice@example.com" });
userContainer.add({ id: 2, name: "Bob", email: "bob@example.com" });

const alice = userContainer.find(user => user.name === "Alice");
console.log(alice); // { id: 1, name: "Alice", email: "alice@example.com" }
```

### this Types and Method Chaining
```typescript
class QueryBuilder {
  private query: string = "";
  
  select(columns: string[]): this {
    this.query += `SELECT ${columns.join(', ')} `;
    return this;
  }
  
  from(table: string): this {
    this.query += `FROM ${table} `;
    return this;
  }
  
  where(condition: string): this {
    this.query += `WHERE ${condition} `;
    return this;
  }
  
  orderBy(column: string, direction: 'ASC' | 'DESC' = 'ASC'): this {
    this.query += `ORDER BY ${column} ${direction} `;
    return this;
  }
  
  limit(count: number): this {
    this.query += `LIMIT ${count} `;
    return this;
  }
  
  build(): string {
    return this.query.trim();
  }
}

class AdvancedQueryBuilder extends QueryBuilder {
  join(table: string, condition: string): this {
    // 'this' refers to AdvancedQueryBuilder, not QueryBuilder
    return this;
  }
}

// Method chaining works with inheritance
const query = new AdvancedQueryBuilder()
  .select(['name', 'email'])
  .from('users')
  .where('age > 18')
  .orderBy('name')
  .limit(10)
  .build();

console.log(query); // "SELECT name, email FROM users WHERE age > 18 ORDER BY name ASC LIMIT 10"
```

### Mixins Pattern
```typescript
// Mixin functions
type Constructor<T = {}> = new (...args: any[]) => T;

function Timestamped<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    timestamp = Date.now();
    
    getTimestamp(): string {
      return new Date(this.timestamp).toISOString();
    }
  };
}

function Activatable<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    isActive = false;
    
    activate(): void {
      this.isActive = true;
    }
    
    deactivate(): void {
      this.isActive = false;
    }
  };
}

// Base class
class User {
  constructor(public name: string) {}
}

// Apply mixins
const TimestampedUser = Timestamped(User);
const ActivatableUser = Activatable(User);
const TimestampedActivatableUser = Timestamped(Activatable(User));

// Usage
const user = new TimestampedActivatableUser("Alice");
user.activate();
console.log(user.name);           // "Alice"
console.log(user.isActive);       // true
console.log(user.getTimestamp()); // "2023-01-01T12:00:00.000Z"
```

---

## Key Interview Questions

### Q1: What are the different visibility modifiers in TypeScript classes?
**Answer:** TypeScript has four visibility modifiers:

```typescript
class Example {
  public name: string;      // Accessible everywhere (default)
  protected id: number;     // Accessible in class and subclasses
  private secret: string;   // Only accessible within this class
  readonly created: Date;   // Cannot be modified after initialization
}
```

### Q2: How do parameter properties work in TypeScript?
**Answer:** Parameter properties let you declare and initialize class properties directly in the constructor:

```typescript
// Instead of this verbose syntax:
class UserVerbose {
  name: string;
  age: number;
  
  constructor(name: string, age: number) {
    this.name = name;
    this.age = age;
  }
}

// Use parameter properties:
class User {
  constructor(
    public name: string,
    private age: number,
    readonly id: string = Math.random().toString()
  ) {}
}
```

### Q3: What's the difference between abstract classes and interfaces?
**Answer:** 
- **Abstract classes** can have both concrete and abstract methods, and can't be instantiated directly
- **Interfaces** only define contracts (method signatures) and can be implemented by multiple classes

```typescript
// Abstract class - can have implementation
abstract class Animal {
  abstract makeSound(): string;  // Must be implemented
  
  move(): string {              // Can have implementation
    return "Moving...";
  }
}

// Interface - only contracts
interface Flyable {
  fly(): void;  // No implementation
}

class Bird extends Animal implements Flyable {
  makeSound(): string { return "Tweet"; }
  fly(): void { console.log("Flying"); }
}
```

### Q4: How do generic classes work in TypeScript?
**Answer:** Generic classes use type parameters to work with multiple types while maintaining type safety:

```typescript
class Stack<T> {
  private items: T[] = [];
  
  push(item: T): void {
    this.items.push(item);
  }
  
  pop(): T | undefined {
    return this.items.pop();
  }
  
  peek(): T | undefined {
    return this.items[this.items.length - 1];
  }
}

const numberStack = new Stack<number>();
const stringStack = new Stack<string>();
```

### Q5: What is the `this` type in TypeScript classes?
**Answer:** The `this` type refers to the current class type and enables proper typing for method chaining and inheritance:

```typescript
class Calculator {
  private value = 0;
  
  add(n: number): this {  // Returns the current class type
    this.value += n;
    return this;
  }
  
  multiply(n: number): this {
    this.value *= n;
    return this;
  }
  
  getValue(): number {
    return this.value;
  }
}

// Method chaining works
const result = new Calculator()
  .add(5)
  .multiply(2)
  .add(3)
  .getValue(); // 13
```

---

## Best Practices

### ✅ Do This
1. **Use parameter properties** for cleaner constructor code
2. **Prefer composition over inheritance** when possible
3. **Use abstract classes** for shared implementation with contracts
4. **Use interfaces** for pure contracts and multiple inheritance
5. **Use `readonly`** for immutable properties
6. **Use proper visibility modifiers** to encapsulate implementation details

### ❌ Avoid This
1. **Don't make everything public** - use proper encapsulation
2. **Don't create deep inheritance hierarchies** - prefer composition
3. **Don't use classes as namespaces** - use modules instead
4. **Don't ignore the `super()` call** in derived class constructors
5. **Don't mix static and instance concerns** in the same class

---

## Next Steps
- **Decorators**: Add metadata and modify class behavior
- **Advanced Patterns**: Mixins, dependency injection, factory patterns
- **Testing**: Unit testing classes and mocking dependencies
- **Performance**: Understanding class instantiation and memory usage
