# TypeScript Mapped Types: Essential Guide

Learn how to transform object types systematically by mapping over their properties.

## Table of Contents
1. [What are Mapped Types?](#what-are-mapped-types)
2. [Basic Mapped Types](#basic-mapped-types)
3. [Mapping Modifiers](#mapping-modifiers)
4. [Key Remapping with as](#key-remapping-with-as)
5. [Advanced Patterns](#advanced-patterns)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Mapped Types?

**Mapped Types** transform existing types by iterating over their properties and applying transformations. They use the `in` operator to loop through keys.

```typescript
// Basic syntax: { [K in keyof T]: NewType }

// Transform all properties to boolean
type OptionsFlags<T> = {
  [Property in keyof T]: boolean;
};

type Features = {
  darkMode: () => void;
  newUserProfile: () => void;
};

type FeatureOptions = OptionsFlags<Features>;
// Result: { darkMode: boolean; newUserProfile: boolean; }
```

**Key Benefits:**
- **Systematic Transformation**: Apply changes to all properties at once
- **Type Safety**: Maintain relationships between original and transformed types
- **DRY Principle**: Avoid repeating similar type definitions

---

## 2. Basic Mapped Types

### Property Type Transformation
```typescript
// Make all properties strings
type Stringify<T> = {
  [K in keyof T]: string;
};

type User = {
  name: string;
  age: number;
  isActive: boolean;
};

type StringUser = Stringify<User>;
// Result: { name: string; age: string; isActive: string; }
```

### Property Value Preservation
```typescript
// Keep original types but make them nullable
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

type User = {
  name: string;
  age: number;
};

type NullableUser = Nullable<User>;
// Result: { name: string | null; age: number | null; }
```

### Function Wrapper Types
```typescript
// Wrap all properties in functions
type Functionify<T> = {
  [K in keyof T]: () => T[K];
};

type Config = {
  apiUrl: string;
  timeout: number;
};

type ConfigGetters = Functionify<Config>;
// Result: { apiUrl: () => string; timeout: () => number; }
```

---

## 3. Mapping Modifiers

### Adding and Removing readonly
```typescript
// Remove readonly modifier
type CreateMutable<T> = {
  -readonly [K in keyof T]: T[K];
};

type LockedAccount = {
  readonly id: string;
  readonly name: string;
  balance: number;
};

type UnlockedAccount = CreateMutable<LockedAccount>;
// Result: { id: string; name: string; balance: number; }

// Add readonly modifier
type CreateReadonly<T> = {
  +readonly [K in keyof T]: T[K];
};

type MutableUser = {
  name: string;
  age: number;
};

type ReadonlyUser = CreateReadonly<MutableUser>;
// Result: { readonly name: string; readonly age: number; }
```

### Adding and Removing Optional
```typescript
// Remove optional modifier (make all required)
type Required<T> = {
  [K in keyof T]-?: T[K];
};

type PartialUser = {
  name?: string;
  age?: number;
  email: string;
};

type CompleteUser = Required<PartialUser>;
// Result: { name: string; age: number; email: string; }

// Add optional modifier
type Partial<T> = {
  [K in keyof T]?: T[K];
};

type User = {
  name: string;
  age: number;
};

type OptionalUser = Partial<User>;
// Result: { name?: string; age?: number; }
```

### Combining Modifiers
```typescript
// Make all properties optional and readonly
type DeepFreeze<T> = {
  +readonly [K in keyof T]?: T[K];
};

type User = {
  name: string;
  age: number;
};

type FrozenUser = DeepFreeze<User>;
// Result: { readonly name?: string; readonly age?: number; }
```

---

## 4. Key Remapping with as

### Basic Key Remapping
```typescript
// Create getter methods for all properties
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

interface Person {
  name: string;
  age: number;
  location: string;
}

type PersonGetters = Getters<Person>;
// Result: {
//   getName: () => string;
//   getAge: () => number;
//   getLocation: () => string;
// }
```

### Filtering Properties
```typescript
// Remove specific properties
type RemoveKind<T> = {
  [K in keyof T as Exclude<K, "kind">]: T[K];
};

interface Circle {
  kind: "circle";
  radius: number;
  color: string;
}

type KindlessCircle = RemoveKind<Circle>;
// Result: { radius: number; color: string; }

// Keep only string properties
type StringProperties<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};

type User = {
  name: string;
  age: number;
  email: string;
};

type UserStrings = StringProperties<User>;
// Result: { name: string; email: string; }
```

### Event Handler Mapping
```typescript
// Map discriminated union to event handlers
type EventConfig<Events extends { kind: string }> = {
  [E in Events as E["kind"]]: (event: E) => void;
};

type SquareEvent = { kind: "square"; x: number; y: number };
type CircleEvent = { kind: "circle"; radius: number };

type Config = EventConfig<SquareEvent | CircleEvent>;
// Result: {
//   square: (event: SquareEvent) => void;
//   circle: (event: CircleEvent) => void;
// }
```

---

## 5. Advanced Patterns

### Conditional Property Transformation
```typescript
// Transform properties based on their types
type ApiEndpoints<T> = {
  [K in keyof T]: T[K] extends (...args: any[]) => any
    ? T[K] // Keep functions as-is
    : () => Promise<T[K]>; // Wrap non-functions in async getters
};

type UserService = {
  getUser: (id: string) => Promise<User>;
  currentUser: User;
  isLoggedIn: boolean;
};

type UserApi = ApiEndpoints<UserService>;
// Result: {
//   getUser: (id: string) => Promise<User>;
//   currentUser: () => Promise<User>;
//   isLoggedIn: () => Promise<boolean>;
// }
```

### Deep Transformation
```typescript
// Recursively make all properties optional
type DeepPartial<T> = {
  [K in keyof T]?: T[K] extends object ? DeepPartial<T[K]> : T[K];
};

type User = {
  name: string;
  profile: {
    avatar: string;
    settings: {
      theme: string;
      notifications: boolean;
    };
  };
};

type PartialUser = DeepPartial<User>;
// Result: {
//   name?: string;
//   profile?: {
//     avatar?: string;
//     settings?: {
//       theme?: string;
//       notifications?: boolean;
//     };
//   };
// }
```

### Database Field Analysis
```typescript
// Extract PII fields for GDPR compliance
type ExtractPII<T> = {
  [K in keyof T]: T[K] extends { pii: true } ? true : false;
};

type DBFields = {
  id: { format: "incrementing" };
  name: { type: string; pii: true };
  email: { type: string; pii: true };
  createdAt: { type: Date };
};

type PIIFields = ExtractPII<DBFields>;
// Result: { id: false; name: true; email: true; createdAt: false; }
```

### Form Validation Types
```typescript
// Create validation schema from data type
type ValidationSchema<T> = {
  [K in keyof T]: {
    required: boolean;
    validator: (value: T[K]) => boolean;
    errorMessage: string;
  };
};

type UserForm = {
  username: string;
  email: string;
  age: number;
};

type UserValidation = ValidationSchema<UserForm>;
// Result: {
//   username: { required: boolean; validator: (value: string) => boolean; errorMessage: string; };
//   email: { required: boolean; validator: (value: string) => boolean; errorMessage: string; };
//   age: { required: boolean; validator: (value: number) => boolean; errorMessage: string; };
// }
```

### State Management Types
```typescript
// Create action creators from state shape
type ActionCreators<T> = {
  [K in keyof T as `set${Capitalize<string & K>}`]: (value: T[K]) => {
    type: `SET_${Uppercase<string & K>}`;
    payload: T[K];
  };
};

type AppState = {
  user: User;
  theme: "light" | "dark";
  loading: boolean;
};

type Actions = ActionCreators<AppState>;
// Result: {
//   setUser: (value: User) => { type: "SET_USER"; payload: User; };
//   setTheme: (value: "light" | "dark") => { type: "SET_THEME"; payload: "light" | "dark"; };
//   setLoading: (value: boolean) => { type: "SET_LOADING"; payload: boolean; };
// }
```

---

## Key Interview Questions

### Q1: What are mapped types and how do they work?
**Answer:** Mapped types transform existing types by iterating over their properties using the `in` operator:

```typescript
type Nullable<T> = {
  [K in keyof T]: T[K] | null;
};

type User = { name: string; age: number };
type NullableUser = Nullable<User>; // { name: string | null; age: number | null; }
```

### Q2: How do mapping modifiers work?
**Answer:** Use `+` to add modifiers, `-` to remove them. `+` is assumed if no prefix:

```typescript
// Remove readonly
type Mutable<T> = {
  -readonly [K in keyof T]: T[K];
};

// Remove optional (make required)
type Required<T> = {
  [K in keyof T]-?: T[K];
};

// Add both readonly and optional
type DeepFreeze<T> = {
  +readonly [K in keyof T]?: T[K];
};
```

### Q3: What is key remapping with `as` and when do you use it?
**Answer:** Key remapping with `as` lets you transform property names:

```typescript
// Create getters
type Getters<T> = {
  [K in keyof T as `get${Capitalize<string & K>}`]: () => T[K];
};

// Filter properties
type StringProps<T> = {
  [K in keyof T as T[K] extends string ? K : never]: T[K];
};
```

### Q4: How do you filter properties in mapped types?
**Answer:** Use conditional types with `never` to exclude properties:

```typescript
// Keep only function properties
type FunctionProps<T> = {
  [K in keyof T as T[K] extends Function ? K : never]: T[K];
};

// Remove specific keys
type OmitId<T> = {
  [K in keyof T as Exclude<K, "id">]: T[K];
};
```

### Q5: How do mapped types work with unions?
**Answer:** Mapped types can iterate over union types, not just object properties:

```typescript
type EventConfig<Events extends { kind: string }> = {
  [E in Events as E["kind"]]: (event: E) => void;
};

type SquareEvent = { kind: "square"; x: number };
type CircleEvent = { kind: "circle"; radius: number };

type Config = EventConfig<SquareEvent | CircleEvent>;
// Result: { square: (event: SquareEvent) => void; circle: (event: CircleEvent) => void; }
```

---

## Best Practices

### ✅ Do This
1. **Use mapped types** for systematic property transformations
2. **Combine with conditional types** for complex logic
3. **Use key remapping** to create derived property names
4. **Leverage modifiers** to control readonly/optional behavior
5. **Create reusable utility types** for common patterns

### ❌ Avoid This
1. **Don't over-complicate** - sometimes simple types are better
2. **Don't forget about built-in utility types** - use `Partial`, `Required`, etc.
3. **Don't ignore performance** - complex mapped types can slow compilation
4. **Don't make types too generic** - balance flexibility with clarity
5. **Don't forget the `string &` trick** for template literals with `keyof`

---

## Next Steps
- **Template Literal Types**: Advanced string manipulation at type level
- **Utility Types**: Built-in TypeScript helpers that use mapped types
- **Advanced Type Patterns**: Combining mapped types with other advanced features
- **Performance Optimization**: Writing efficient mapped types
