# TypeScript Indexed Access Types: Essential Guide

Learn how to access and extract specific properties from types using bracket notation.

## Table of Contents
1. [What are Indexed Access Types?](#1-what-are-indexed-access-types)
2. [Basic Property Access](#2-basic-property-access)
3. [Union and keyof Access](#3-union-and-keyof-access)
4. [Array Element Types](#4-array-element-types)
5. [Practical Applications](#5-practical-applications)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. What are Indexed Access Types?

**Indexed Access Types** let you extract the type of a specific property from another type using bracket notation `T[K]`.

```typescript
type Person = {
  name: string;
  age: number;
  email: string;
  isActive: boolean;
};

// Extract specific property types
type PersonName = Person["name"];     // string
type PersonAge = Person["age"];       // number
type PersonEmail = Person["email"];   // string
type PersonActive = Person["isActive"]; // boolean

// Use the extracted types
const userName: PersonName = "Alice";     // ✅ string
const userAge: PersonAge = 30;            // ✅ number
// const invalidAge: PersonAge = "thirty"; // ❌ Error
```

**Key Benefits:**
- **Type Safety**: Ensures property exists on the type
- **Automatic Updates**: Changes to source type automatically update extracted types
- **Flexibility**: Works with unions, keyof, and complex type expressions

---

## 2. Basic Property Access

### Simple Property Extraction
```typescript
type User = {
  id: string;
  profile: {
    name: string;
    avatar: string;
  };
  settings: {
    theme: "light" | "dark";
    notifications: boolean;
  };
};

// Extract top-level properties
type UserId = User["id"];           // string
type UserProfile = User["profile"]; // { name: string; avatar: string; }
type UserSettings = User["settings"]; // { theme: "light" | "dark"; notifications: boolean; }

// Extract nested properties
type UserName = User["profile"]["name"];       // string
type UserTheme = User["settings"]["theme"];    // "light" | "dark"
type UserNotifications = User["settings"]["notifications"]; // boolean
```

### Error Handling
```typescript
type Person = { name: string; age: number };

// ✅ Valid property access
type PersonName = Person["name"]; // string

// ❌ Error: Property doesn't exist
// type Invalid = Person["height"]; // Property 'height' does not exist on type 'Person'
```

### Dynamic Property Access
```typescript
type ApiResponse = {
  data: any;
  status: number;
  message: string;
};

// Create a function that extracts property types
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const response: ApiResponse = {
  data: { users: [] },
  status: 200,
  message: "Success"
};

const status = getProperty(response, "status");   // number
const message = getProperty(response, "message"); // string
```

---

## 3. Union and keyof Access

### Union Type Access
```typescript
type Person = { name: string; age: number; email: string };

// Access multiple properties at once
type NameOrAge = Person["name" | "age"];        // string | number
type NameOrEmail = Person["name" | "email"];    // string | string = string
type AllBasicInfo = Person["name" | "age" | "email"]; // string | number
```

### keyof Access
```typescript
type Person = { name: string; age: number; isActive: boolean };

// Get all property types as a union
type AllPersonValues = Person[keyof Person]; // string | number | boolean

// Equivalent to:
type AllPersonValuesExplicit = Person["name" | "age" | "isActive"];
```

### Conditional Access with Type Aliases
```typescript
type Person = { name: string; age: number; email: string };

// Create reusable key types
type PersonStringKeys = "name" | "email";
type PersonNumberKeys = "age";

type PersonStringValues = Person[PersonStringKeys]; // string
type PersonNumberValues = Person[PersonNumberKeys]; // number

// Use in functions
function getStringProperty<K extends PersonStringKeys>(
  person: Person, 
  key: K
): Person[K] {
  return person[key]; // Returns string
}
```

---

## 4. Array Element Types

### Basic Array Element Access
```typescript
const fruits = ["apple", "banana", "orange"];
type Fruit = typeof fruits[number]; // string

const numbers = [1, 2, 3, 4, 5];
type NumberElement = typeof numbers[number]; // number

// More complex array
const users = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 },
  { name: "Charlie", age: 35 }
];

type User = typeof users[number]; // { name: string; age: number; }
type UserName = typeof users[number]["name"]; // string
type UserAge = typeof users[number]["age"];   // number
```

### Tuple Element Access
```typescript
type UserTuple = [string, number, boolean]; // [name, age, isActive]

type UserName = UserTuple[0];     // string
type UserAge = UserTuple[1];      // number
type UserActive = UserTuple[2];   // boolean

// Access all elements
type AllTupleElements = UserTuple[number]; // string | number | boolean
```

### Array Method Return Types
```typescript
const apiEndpoints = [
  { path: "/users", method: "GET" as const },
  { path: "/users", method: "POST" as const },
  { path: "/posts", method: "GET" as const }
] as const;

type Endpoint = typeof apiEndpoints[number];
// Type: { readonly path: "/users" | "/posts"; readonly method: "GET" | "POST"; }

type EndpointPath = typeof apiEndpoints[number]["path"];   // "/users" | "/posts"
type EndpointMethod = typeof apiEndpoints[number]["method"]; // "GET" | "POST"
```

---

## 5. Practical Applications

### Form Field Types
```typescript
const formSchema = {
  username: { type: "string", required: true },
  email: { type: "email", required: true },
  age: { type: "number", required: false },
  terms: { type: "boolean", required: true }
} as const;

type FormSchema = typeof formSchema;
type FormField = FormSchema[keyof FormSchema];
// Type: { readonly type: "string" | "email" | "number" | "boolean"; readonly required: boolean; }

type FieldType = FormField["type"]; // "string" | "email" | "number" | "boolean"

// Create form data type
type FormData = {
  [K in keyof FormSchema]: FormSchema[K]["type"] extends "string" | "email" 
    ? string 
    : FormSchema[K]["type"] extends "number" 
    ? number 
    : FormSchema[K]["type"] extends "boolean" 
    ? boolean 
    : never;
};
// Result: { username: string; email: string; age: number; terms: boolean; }
```

### API Response Type Extraction
```typescript
const mockApiResponse = {
  user: {
    id: "123",
    profile: {
      name: "Alice",
      email: "alice@example.com"
    },
    preferences: {
      theme: "dark" as const,
      language: "en" as const
    }
  },
  meta: {
    timestamp: "2023-01-01",
    version: "1.0"
  }
} as const;

type ApiResponse = typeof mockApiResponse;

// Extract nested types
type User = ApiResponse["user"];
type UserProfile = ApiResponse["user"]["profile"];
type UserPreferences = ApiResponse["user"]["preferences"];
type Meta = ApiResponse["meta"];

// Extract specific values
type UserId = ApiResponse["user"]["id"];           // "123"
type UserTheme = ApiResponse["user"]["preferences"]["theme"]; // "dark"
type ApiVersion = ApiResponse["meta"]["version"];   // "1.0"
```

### Database Model Types
```typescript
const dbSchema = {
  users: {
    id: "string",
    name: "string",
    email: "string",
    createdAt: "date"
  },
  posts: {
    id: "string",
    title: "string",
    content: "string",
    authorId: "string",
    publishedAt: "date"
  }
} as const;

type DbSchema = typeof dbSchema;
type TableNames = keyof DbSchema; // "users" | "posts"

type UserFields = DbSchema["users"];  // { readonly id: "string"; readonly name: "string"; ... }
type PostFields = DbSchema["posts"];  // { readonly id: "string"; readonly title: "string"; ... }

// Extract field types for a specific table
type UserFieldTypes = DbSchema["users"][keyof DbSchema["users"]]; // "string" | "date"

// Create actual model types
type User = {
  [K in keyof DbSchema["users"]]: DbSchema["users"][K] extends "string" 
    ? string 
    : DbSchema["users"][K] extends "date" 
    ? Date 
    : never;
};
// Result: { id: string; name: string; email: string; createdAt: Date; }
```

### Event Handler Types
```typescript
const eventHandlers = {
  onClick: (event: MouseEvent) => void 0,
  onKeyDown: (event: KeyboardEvent) => void 0,
  onFocus: (event: FocusEvent) => void 0,
  onSubmit: (event: SubmitEvent) => void 0
};

type EventHandlers = typeof eventHandlers;
type EventNames = keyof EventHandlers; // "onClick" | "onKeyDown" | "onFocus" | "onSubmit"

// Extract parameter types
type ClickEventType = Parameters<EventHandlers["onClick"]>[0];   // MouseEvent
type KeyEventType = Parameters<EventHandlers["onKeyDown"]>[0];   // KeyboardEvent
type FocusEventType = Parameters<EventHandlers["onFocus"]>[0];   // FocusEvent
```

---

## Key Interview Questions

### Q1: What are indexed access types and how do they work?
**Answer:** Indexed access types use bracket notation `T[K]` to extract the type of a specific property from another type:

```typescript
type Person = { name: string; age: number };
type PersonName = Person["name"]; // string
type PersonAge = Person["age"];   // number
```

### Q2: How do you access multiple properties at once?
**Answer:** Use union types in the bracket notation:

```typescript
type Person = { name: string; age: number; email: string };
type NameOrAge = Person["name" | "age"];        // string | number
type AllValues = Person[keyof Person];          // string | number
```

### Q3: How do you get the element type of an array?
**Answer:** Use `number` as the index to get the element type:

```typescript
const users = [{ name: "Alice", age: 30 }];
type User = typeof users[number]; // { name: string; age: number; }

// Or with type directly
type StringArray = string[];
type StringElement = StringArray[number]; // string
```

### Q4: Can you use variables as indices in indexed access types?
**Answer:** No, you can only use types as indices, not values:

```typescript
const key = "name";
type Person = { name: string; age: number };

// ❌ Error: Can't use value as index
// type PersonName = Person[key];

// ✅ Use type alias instead
type Key = "name";
type PersonName = Person[Key]; // string

// ✅ Or use typeof if you need the value's type
type KeyType = typeof key; // "name"
type PersonName2 = Person[KeyType]; // string
```

### Q5: How do indexed access types work with nested properties?
**Answer:** Chain the bracket notation to access nested properties:

```typescript
type User = {
  profile: {
    personal: {
      name: string;
      age: number;
    };
  };
};

type UserName = User["profile"]["personal"]["name"]; // string

// Or extract intermediate types
type Profile = User["profile"];
type Personal = Profile["personal"];
type Name = Personal["name"]; // string
```

---

## Best Practices

### ✅ Do This
1. **Use indexed access types** to maintain type relationships automatically
2. **Combine with keyof** to access all property types as unions
3. **Use with typeof** to extract types from array literals
4. **Chain access** for nested property types
5. **Use type aliases** for complex or reused index expressions

### ❌ Avoid This
1. **Don't use values as indices** - only types work in bracket notation
2. **Don't access non-existent properties** - TypeScript will error
3. **Don't over-complicate** - sometimes explicit types are clearer
4. **Don't forget const assertions** when working with literal arrays
5. **Don't mix up runtime and type-level operations**

---

## Next Steps
- **Conditional Types**: Type-level if statements for complex logic
- **Mapped Types**: Transform all properties of a type systematically
- **Template Literal Types**: Advanced string manipulation at type level
- **Utility Types**: Built-in TypeScript helpers for common patterns
