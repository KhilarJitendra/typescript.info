# TypeScript Everyday Types: Essential Guide

Learn the most common types you'll use in everyday TypeScript development.

## Table of Contents
1. [Primitive Types](#primitive-types)
2. [Arrays and Objects](#arrays-and-objects)
3. [Union Types](#union-types)
4. [Type Aliases and Interfaces](#type-aliases-and-interfaces)
5. [Literal Types](#literal-types)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. Primitive Types

The three fundamental types in TypeScript:

```typescript
// String
let name: string = "Alice";
let message: string = `Hello, ${name}!`;

// Number (includes integers, floats, hex, binary, octal)
let age: number = 30;
let price: number = 99.99;
let hex: number = 0xff;

// Boolean
let isActive: boolean = true;
let isComplete: boolean = false;
```

**Important**: Always use lowercase (`string`, `number`, `boolean`), not uppercase (`String`, `Number`, `Boolean`).

### The `any` Type (Avoid It!)

```typescript
let data: any = "hello";
data = 42;
data.foo.bar.baz; // No error, but dangerous!

// Better alternatives:
let data: unknown = "hello";     // Forces type checking
let data: string | number = "hello"; // Specific union
```

---

## 2. Arrays and Objects

### Arrays
```typescript
// Two equivalent syntaxes
let numbers: number[] = [1, 2, 3];
let strings: Array<string> = ["a", "b", "c"];

// Array methods maintain type safety
let doubled = numbers.map(n => n * 2);        // number[]
let filtered = numbers.filter(n => n > 1);    // number[]
```

### Objects
```typescript
// Inline object type
function greet(person: { name: string; age: number }) {
  return `Hello ${person.name}, age ${person.age}`;
}

// Optional properties
interface User {
  name: string;
  email?: string; // Optional
}

// Safe handling of optional properties
function processUser({ name, email = "No email" }: User) {
  console.log(`${name}: ${email}`);
}
```

---

## 3. Union Types

Combine multiple types with `|`:

```typescript
function printId(id: string | number) {
  console.log(`ID: ${id}`);
}

printId(123);     // ✅ OK
printId("abc");   // ✅ OK
// printId(true); // ❌ Error
```

### Type Narrowing
```typescript
function processValue(value: string | number) {
  if (typeof value === "string") {
    // value is string here
    console.log(value.toUpperCase());
  } else {
    // value is number here
    console.log(value.toFixed(2));
  }
}
```

---

## 4. Type Aliases and Interfaces

### Type Aliases
```typescript
type Point = {
  x: number;
  y: number;
};

type ID = string | number;
type Status = "pending" | "approved" | "rejected";
```

### Interfaces
```typescript
interface User {
  name: string;
  age: number;
}

// Extending interfaces
interface AdminUser extends User {
  permissions: string[];
}
```

### When to Use Which?
- **Interface**: For object shapes that might be extended
- **Type alias**: For unions, primitives, or computed types

```typescript
// ✅ Interface - extensible
interface Person {
  name: string;
}

// ✅ Type alias - unions
type Status = "active" | "inactive";
type PersonWithStatus = Person & { status: Status };
```

---

## 5. Literal Types

Exact values as types:

```typescript
// String literals
type Direction = "up" | "down" | "left" | "right";

function move(direction: Direction) {
  console.log(`Moving ${direction}`);
}

move("up");    // ✅ OK
// move("north"); // ❌ Error

// Number literals
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

// Boolean literals
type Success = true;
type Failure = false;
```

### `as const` for Literal Types
```typescript
// Without as const
const colors = ["red", "green", "blue"]; // string[]

// With as const
const colors = ["red", "green", "blue"] as const; // readonly ["red", "green", "blue"]
```

---

## Key Interview Questions

### Q1: What are the three primitive types in TypeScript?
**Answer:** `string`, `number`, and `boolean`. Always use lowercase, not the uppercase wrapper types (`String`, `Number`, `Boolean`).

### Q2: What's the difference between `any` and `unknown`?
**Answer:** 
- `any` disables type checking completely
- `unknown` requires type checking before use

```typescript
let a: any = "hello";
console.log(a.toUpperCase()); // No error

let b: unknown = "hello";
// console.log(b.toUpperCase()); // ❌ Error
if (typeof b === "string") {
  console.log(b.toUpperCase()); // ✅ OK after check
}
```

### Q3: How do you safely work with union types?
**Answer:** Use type narrowing with `typeof`, `instanceof`, or other type guards:

```typescript
function processValue(value: string | number) {
  if (typeof value === "string") {
    return value.toUpperCase(); // string methods
  } else {
    return value.toFixed(2);    // number methods
  }
}
```

### Q4: Interface vs Type Alias - when to use which?
**Answer:**
- **Interface**: For object contracts that might be extended
- **Type alias**: For unions, primitives, and computed types

### Q5: What are literal types and when are they useful?
**Answer:** Literal types represent exact values. They're useful for creating precise APIs:

```typescript
type Theme = "light" | "dark";
type HttpMethod = "GET" | "POST" | "PUT" | "DELETE";

function setTheme(theme: Theme) {
  // Only accepts "light" or "dark"
}
```

---

## Best Practices

### ✅ Do This
1. **Use primitive types** (`string`, `number`, `boolean`)
2. **Prefer `unknown` over `any`** for truly unknown data
3. **Use union types** for multiple possibilities
4. **Use type narrowing** to work safely with unions
5. **Choose interfaces for extensible objects**
6. **Use literal types** for precise APIs

### ❌ Avoid This
1. **Don't use `any`** unless absolutely necessary
2. **Don't use uppercase primitive types** (`String`, `Number`, `Boolean`)
3. **Don't ignore union type errors** - use type narrowing
4. **Don't over-complicate types** - keep them simple and readable

---

## Next Steps
- **Type Narrowing**: Advanced type safety techniques
- **Functions**: Type-safe function patterns
- **Objects**: Complex object type patterns
- **Generics**: Reusable type-safe code