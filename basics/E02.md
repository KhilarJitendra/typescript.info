# TypeScript Everyday Types: Your Complete Guide to Common Types

Welcome to the world of TypeScript types! This chapter covers the most common types you'll encounter in everyday TypeScript development. These fundamental types form the building blocks for more complex type constructs and are essential for writing type-safe code.

## Table of Contents
1. [Primitive Types](#primitive-types)
2. [Arrays](#arrays)
3. [The Any Type (And Why to Avoid It)](#the-any-type-and-why-to-avoid-it)
4. [Type Annotations on Variables](#type-annotations-on-variables)
5. [Functions and Type Annotations](#functions-and-type-annotations)
6. [Object Types](#object-types)
7. [Union Types](#union-types)
8. [Type Aliases](#type-aliases)
9. [Interfaces](#interfaces)
10. [Type Assertions](#type-assertions)
11. [Literal Types](#literal-types)
12. [Null and Undefined](#null-and-undefined)
13. [Less Common Primitives](#less-common-primitives)

---

## 1. Primitive Types

JavaScript has three fundamental primitive types, and TypeScript provides corresponding types for each:

### String Type
```typescript
let message: string = "Hello, TypeScript!";
let template: string = `Welcome, ${message}`;
let singleQuote: string = 'Also valid';

// Type is automatically inferred
let inferredString = "TypeScript knows this is a string";
```

### Number Type
```typescript
let integer: number = 42;
let decimal: number = 3.14159;
let hex: number = 0xf00d;
let binary: number = 0b1010;
let octal: number = 0o744;

// JavaScript doesn't distinguish between int and float
// Everything is just 'number'
let calculation: number = integer + decimal;
```

### Boolean Type
```typescript
let isActive: boolean = true;
let isComplete: boolean = false;

// Common in conditional logic
let hasPermission: boolean = user.role === 'admin';
```

### ‚ö†Ô∏è Important Note on Capitalization
```typescript
// ‚úÖ Correct - use lowercase
let name: string = "Alice";
let age: number = 30;
let active: boolean = true;

// ‚ùå Avoid - uppercase refers to wrapper objects
let name: String = "Alice";  // Rarely used, refers to String object
let age: Number = 30;        // Rarely used, refers to Number object
let active: Boolean = true;  // Rarely used, refers to Boolean object
```

---

## 2. Arrays

TypeScript provides multiple ways to define array types:

### Array Syntax
```typescript
// Method 1: Type followed by []
let numbers: number[] = [1, 2, 3, 4, 5];
let names: string[] = ["Alice", "Bob", "Charlie"];
let flags: boolean[] = [true, false, true];

// Method 2: Generic Array<Type> syntax
let scores: Array<number> = [95, 87, 92];
let colors: Array<string> = ["red", "green", "blue"];
```

### Working with Arrays
```typescript
let fruits: string[] = ["apple", "banana", "orange"];

// Array methods maintain type safety
fruits.push("grape");        // ‚úÖ Valid
fruits.push(42);            // ‚ùå Error: number not assignable to string

// Array access
let firstFruit: string = fruits[0];
let length: number = fruits.length;

// Array methods return correct types
let uppercased: string[] = fruits.map(fruit => fruit.toUpperCase());
```

### Mixed Type Arrays
```typescript
// Union type arrays
let mixedData: (string | number)[] = ["Alice", 30, "Bob", 25];

// Array of objects
let users: { name: string; age: number }[] = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 }
];
```

---

## 3. The Any Type (And Why to Avoid It)

The `any` type is TypeScript's escape hatch that disables type checking:

### What `any` Does
```typescript
let anything: any = 42;

// All of these are "valid" with any
anything = "Hello";           // No error
anything = true;             // No error
anything = { x: 1, y: 2 };   // No error
anything.foo.bar.baz;        // No error (but might crash at runtime!)
anything();                  // No error (but might crash at runtime!)
```

### Why `any` is Dangerous
```typescript
let userInput: any = getUserInput(); // Could be anything!

// These all compile but might crash at runtime
console.log(userInput.toUpperCase());  // What if userInput is a number?
userInput.push("item");                // What if userInput isn't an array?
let result = userInput * 2;            // What if userInput is a string?
```

### Better Alternatives to `any`
```typescript
// ‚úÖ Use unknown for truly unknown data
let userInput: unknown = getUserInput();
if (typeof userInput === 'string') {
  console.log(userInput.toUpperCase()); // Safe!
}

// ‚úÖ Use union types for multiple possibilities
let id: string | number = getId();

// ‚úÖ Use object types for structured data
let user: { name: string; age: number } = getUser();
```

### The `noImplicitAny` Flag
```typescript
// With noImplicitAny enabled, this causes an error
function process(data) {  // ‚ùå Parameter 'data' implicitly has an 'any' type
  return data.something;
}

// Fix by adding explicit types
function process(data: unknown) {  // ‚úÖ Explicit type
  // Now you must check the type before using it
}
```

---

## 4. Type Annotations on Variables

### When to Use Type Annotations
```typescript
// ‚úÖ Type annotation needed - can't infer from context
let userId: string;
userId = getCurrentUserId();

// ‚úÖ Type annotation helpful for clarity
let isLoggedIn: boolean = checkAuthStatus();

// ‚ùå Usually unnecessary - TypeScript can infer
let message: string = "Hello";  // TypeScript knows this is string
let count: number = 0;          // TypeScript knows this is number
```

### TypeScript's Type Inference
```typescript
// TypeScript automatically infers these types
let name = "Alice";           // inferred as string
let age = 30;                 // inferred as number
let isActive = true;          // inferred as boolean
let scores = [95, 87, 92];    // inferred as number[]

// You can verify inferred types by hovering in your IDE
let inferredType = "TypeScript is smart!"; // Hover to see: string
```

---

## 5. Functions and Type Annotations

### Parameter Type Annotations
```typescript
// Basic parameter typing
function greet(name: string): void {
  console.log(`Hello, ${name}!`);
}

function add(a: number, b: number): number {
  return a + b;
}

// TypeScript checks argument types
greet("Alice");    // ‚úÖ Valid
greet(42);         // ‚ùå Error: number not assignable to string
```

### Return Type Annotations
```typescript
// Explicit return type
function multiply(a: number, b: number): number {
  return a * b;
}

// TypeScript can usually infer return types
function divide(a: number, b: number) {  // inferred return type: number
  return a / b;
}

// Void return type for functions that don't return anything
function logMessage(message: string): void {
  console.log(message);
  // No return statement needed
}
```

### Functions Returning Promises
```typescript
// Async functions return Promise<T>
async function fetchUser(id: string): Promise<User> {
  const response = await fetch(`/api/users/${id}`);
  return response.json();
}

// Using the async function
async function displayUser() {
  const user = await fetchUser("123"); // user is of type User
  console.log(user.name);
}
```

### Anonymous Functions and Contextual Typing
```typescript
const names = ["Alice", "Bob", "Charlie"];

// TypeScript infers 's' is string from context
names.forEach(function(s) {
  console.log(s.toUpperCase()); // s is known to be string
});

// Same with arrow functions
names.forEach(s => {
  console.log(s.length); // s is still known to be string
});

// Context helps with array methods
const lengths = names.map(name => name.length); // returns number[]
```

---

## 6. Object Types

### Defining Object Types
```typescript
// Inline object type
function printCoord(pt: { x: number; y: number }) {
  console.log(`Coordinates: (${pt.x}, ${pt.y})`);
}

printCoord({ x: 3, y: 7 });
```

### Optional Properties
```typescript
function printName(obj: { first: string; last?: string }) {
  console.log(`Name: ${obj.first}`);
  
  // Must check for undefined with optional properties
  if (obj.last !== undefined) {
    console.log(`Full name: ${obj.first} ${obj.last}`);
  }
  
  // Or use optional chaining
  console.log(`Last name length: ${obj.last?.length ?? 0}`);
}

// Both calls are valid
printName({ first: "Bob" });
printName({ first: "Alice", last: "Smith" });
```

### Object Property Separators
```typescript
// You can use either comma or semicolon
type User = {
  name: string,    // comma
  age: number;     // semicolon
  email: string    // no separator on last property (optional)
};
```

---

## 7. Union Types

### Creating Union Types
```typescript
// Basic union type
function printId(id: number | string) {
  console.log(`Your ID is: ${id}`);
}

printId(101);        // ‚úÖ Valid
printId("ABC123");   // ‚úÖ Valid
printId(true);       // ‚ùå Error: boolean not assignable
```

### Working with Union Types - Type Narrowing
```typescript
function printId(id: number | string) {
  // ‚ùå This won't work - toUpperCase doesn't exist on number
  // console.log(id.toUpperCase());
  
  // ‚úÖ Use type narrowing
  if (typeof id === "string") {
    console.log(id.toUpperCase()); // TypeScript knows id is string here
  } else {
    console.log(id.toFixed(2));    // TypeScript knows id is number here
  }
}
```

### Advanced Union Type Narrowing
```typescript
function welcomePeople(x: string[] | string) {
  if (Array.isArray(x)) {
    // TypeScript knows x is string[] here
    console.log("Hello, " + x.join(" and "));
  } else {
    // TypeScript knows x is string here
    console.log("Welcome lone traveler " + x);
  }
}
```

### Common Properties in Unions
```typescript
// Both arrays and strings have slice method
function getFirstThree(x: number[] | string) {
  return x.slice(0, 3); // Works on both types!
}

console.log(getFirstThree("Hello World")); // "Hel"
console.log(getFirstThree([1, 2, 3, 4, 5])); // [1, 2, 3]
```

---

## 8. Type Aliases

### Creating Type Aliases
```typescript
// Object type alias
type Point = {
  x: number;
  y: number;
};

function printCoord(pt: Point) {
  console.log(`The coordinate's x value is ${pt.x}`);
  console.log(`The coordinate's y value is ${pt.y}`);
}

printCoord({ x: 100, y: 100 });
```

### Union Type Aliases
```typescript
type ID = number | string;
type Status = "pending" | "approved" | "rejected";

function updateStatus(id: ID, status: Status) {
  console.log(`Updating ${id} to ${status}`);
}

updateStatus(123, "approved");        // ‚úÖ Valid
updateStatus("ABC", "pending");       // ‚úÖ Valid
updateStatus(123, "invalid");         // ‚ùå Error: not a valid status
```

### Complex Type Aliases
```typescript
type User = {
  id: ID;
  name: string;
  email: string;
  status: Status;
  preferences?: {
    theme: "light" | "dark";
    notifications: boolean;
  };
};

const user: User = {
  id: "user123",
  name: "Alice",
  email: "alice@example.com",
  status: "approved"
};
```

---

## 9. Interfaces

### Basic Interface Declaration
```typescript
interface Point {
  x: number;
  y: number;
}

function printCoord(pt: Point) {
  console.log(`The coordinate's x value is ${pt.x}`);
  console.log(`The coordinate's y value is ${pt.y}`);
}

printCoord({ x: 100, y: 100 });
```

### Interface vs Type Alias Comparison

| Feature | Interface | Type Alias |
|---------|-----------|------------|
| **Extending** | `extends` keyword | Intersection (`&`) |
| **Declaration Merging** | ‚úÖ Supported | ‚ùå Not supported |
| **Primitives** | ‚ùå Objects only | ‚úÖ Any type |
| **Computed Properties** | ‚ùå Limited | ‚úÖ Full support |

### Interface Extension
```typescript
interface Animal {
  name: string;
}

interface Bear extends Animal {
  honey: boolean;
}

const bear: Bear = {
  name: "Winnie",
  honey: true
};
```

### Type Alias with Intersection
```typescript
type Animal = {
  name: string;
};

type Bear = Animal & {
  honey: boolean;
};

const bear: Bear = {
  name: "Winnie",
  honey: true
};
```

### Declaration Merging (Interface Only)
```typescript
interface Window {
  title: string;
}

interface Window {
  ts: TypeScriptAPI;
}

// Now Window has both title and ts properties
const w: Window = {
  title: "My App",
  ts: typescript
};
```

### When to Use Which?
```typescript
// ‚úÖ Use interface for object shapes that might be extended
interface User {
  name: string;
  email: string;
}

interface AdminUser extends User {
  permissions: string[];
}

// ‚úÖ Use type alias for unions, primitives, and computed types
type Status = "loading" | "success" | "error";
type EventHandler<T> = (event: T) => void;
type UserKeys = keyof User; // "name" | "email"
```

---

## 10. Type Assertions

### Basic Type Assertions
```typescript
// When you know more than TypeScript
const myCanvas = document.getElementById("main_canvas") as HTMLCanvasElement;

// Alternative syntax (not usable in .tsx files)
const myCanvas2 = <HTMLCanvasElement>document.getElementById("main_canvas");
```

### When Type Assertions Are Useful
```typescript
// Working with DOM elements
const input = document.getElementById("user-input") as HTMLInputElement;
console.log(input.value); // TypeScript knows this is an input element

// Working with API responses
interface User {
  name: string;
  email: string;
}

const userData = JSON.parse(jsonString) as User;
console.log(userData.name); // TypeScript trusts this is a User
```

### Type Assertion Rules and Safety
```typescript
// ‚ùå Invalid - can't assert between unrelated types
const x = "hello" as number; // Error!

// ‚úÖ Valid - can assert to more or less specific types
const y = "hello" as any as number; // Escape hatch (dangerous!)

// ‚úÖ Better approach - use unknown as intermediate
const z = (someValue as unknown) as TargetType;
```

### Non-null Assertion Operator
```typescript
function liveDangerously(x?: number | null) {
  // Use ! to assert value is not null/undefined
  console.log(x!.toFixed()); // Tells TypeScript x is definitely not null
}

// ‚ö†Ô∏è Be careful - this can cause runtime errors if x is actually null!
```

---

## 11. Literal Types

### String Literal Types
```typescript
// Single value type
let direction: "left" | "right" | "center" = "left";

function printText(s: string, alignment: "left" | "right" | "center") {
  console.log(`Text: ${s}, aligned: ${alignment}`);
}

printText("Hello", "left");     // ‚úÖ Valid
printText("Hello", "centre");   // ‚ùå Error: "centre" not allowed
```

### Numeric Literal Types
```typescript
function compare(a: string, b: string): -1 | 0 | 1 {
  return a === b ? 0 : a > b ? 1 : -1;
}

// Function can only return these specific numbers
const result = compare("apple", "banana"); // result is -1 | 0 | 1
```

### Boolean Literal Types
```typescript
// boolean is actually just true | false
type MyBoolean = true | false; // Same as boolean

// Useful for specific boolean values
interface FeatureFlags {
  darkMode: true;  // Must be true
  beta: false;     // Must be false
}
```

### Combining Literals with Other Types
```typescript
interface Options {
  width: number;
}

function configure(x: Options | "auto") {
  if (x === "auto") {
    // Handle auto configuration
  } else {
    // x is Options here
    console.log(x.width);
  }
}

configure({ width: 100 });  // ‚úÖ Valid
configure("auto");          // ‚úÖ Valid
configure("automatic");     // ‚ùå Error
```

### Literal Inference Issues and Solutions
```typescript
// Problem: TypeScript infers string, not literal
const req = { url: "https://example.com", method: "GET" };

declare function handleRequest(url: string, method: "GET" | "POST"): void;

handleRequest(req.url, req.method); // ‚ùå Error: string not assignable to "GET" | "POST"

// Solution 1: Type assertion
const req1 = { url: "https://example.com", method: "GET" as "GET" };

// Solution 2: as const
const req2 = { url: "https://example.com", method: "GET" } as const;

// Solution 3: Explicit typing
const req3: { url: string; method: "GET" | "POST" } = {
  url: "https://example.com",
  method: "GET"
};
```

---

## 12. Null and Undefined

### Understanding Null and Undefined
```typescript
// JavaScript has two "empty" values
let nothing: null = null;
let notSet: undefined = undefined;

// TypeScript has corresponding types
let maybeString: string | null = null;
let maybeNumber: number | undefined = undefined;
```

### strictNullChecks Configuration

#### With strictNullChecks OFF (not recommended)
```typescript
// ‚ö†Ô∏è Dangerous - can lead to runtime errors
let name: string = null;        // No error
let age: number = undefined;    // No error

name.toUpperCase();  // Compiles but crashes at runtime!
```

#### With strictNullChecks ON (recommended)
```typescript
// ‚úÖ Safe - must handle null/undefined explicitly
let name: string | null = null;

// ‚ùå Error - must check for null first
// name.toUpperCase();

// ‚úÖ Safe - check before using
if (name !== null) {
  name.toUpperCase(); // TypeScript knows name is string here
}

// ‚úÖ Safe - use optional chaining
name?.toUpperCase();
```

### Handling Null and Undefined
```typescript
function processUser(user: { name: string; email?: string } | null) {
  // Check for null user
  if (user === null) {
    console.log("No user provided");
    return;
  }
  
  // user is definitely not null here
  console.log(`User: ${user.name}`);
  
  // Check for optional email
  if (user.email !== undefined) {
    console.log(`Email: ${user.email}`);
  }
  
  // Or use optional chaining
  console.log(`Email length: ${user.email?.length ?? 0}`);
}
```

### Non-null Assertion Operator (!)
```typescript
function riskyFunction(x?: string | null) {
  // ‚ö†Ô∏è Use with caution - bypasses null checks
  console.log(x!.toUpperCase()); // Assumes x is not null/undefined
}

// Only use when you're absolutely certain the value exists
const element = document.getElementById("my-element")!; // Assumes element exists
```

---

## 13. Less Common Primitives

### BigInt
```typescript
// For very large integers (ES2020+)
const oneHundred: bigint = BigInt(100);
const anotherHundred: bigint = 100n;

// BigInt and number are not compatible
let regular: number = 100;
let big: bigint = 100n;

// ‚ùå Error - can't mix bigint and number
// let sum = regular + big;

// ‚úÖ Convert between types explicitly
let sum = regular + Number(big);
let bigSum = BigInt(regular) + big;
```

### Symbol
```typescript
// Creates globally unique identifiers
const firstName = Symbol("name");
const secondName = Symbol("name");

// Even with same description, symbols are unique
console.log(firstName === secondName); // false

// Common use case: object keys
const ID = Symbol("id");
const user = {
  [ID]: "user123",
  name: "Alice"
};

console.log(user[ID]); // "user123"
```

---

## Interview Questions & Answers

### üéØ **Fundamental Type Questions**

**Q1: What are the three primitive types in TypeScript and how do they differ from their JavaScript counterparts?**

**Answer:** TypeScript has three primitive types: `string`, `number`, and `boolean`. Unlike JavaScript, TypeScript provides compile-time type checking for these types. In JavaScript, you only discover type errors at runtime, but TypeScript catches them during development.

```typescript
// TypeScript catches this error at compile time
let age: number = "thirty"; // ‚ùå Error: Type 'string' is not assignable to type 'number'

// JavaScript would only fail at runtime
let result = age * 2; // Runtime error in JS, compile error in TS
```

**Q2: What's the difference between `string` and `String` in TypeScript?**

**Answer:** `string` (lowercase) refers to the primitive string type, while `String` (uppercase) refers to the String wrapper object. Always use lowercase `string` for type annotations.

```typescript
let name: string = "Alice";    // ‚úÖ Correct - primitive type
let name: String = "Alice";    // ‚ùå Avoid - wrapper object type
```

---

### üö´ **The `any` Type Questions**

**Q3: What is the `any` type and why should you avoid it?**

**Answer:** The `any` type disables TypeScript's type checking, essentially turning TypeScript back into JavaScript. It should be avoided because:
- It defeats the purpose of using TypeScript
- It can hide runtime errors
- It provides no IntelliSense or autocomplete
- It makes refactoring dangerous

```typescript
let data: any = "hello";
data.push("world"); // No error, but will crash at runtime!

// Better alternatives:
let data: unknown = "hello";        // Forces type checking
let data: string | number = "hello"; // Specific union type
```

**Q4: What's the difference between `any` and `unknown`?**

**Answer:** `unknown` is the type-safe counterpart to `any`. While `any` allows any operation, `unknown` requires type checking before use.

```typescript
let value: any = "hello";
console.log(value.toUpperCase()); // No error

let value2: unknown = "hello";
console.log(value2.toUpperCase()); // ‚ùå Error: Object is of type 'unknown'

// Must check type first
if (typeof value2 === 'string') {
  console.log(value2.toUpperCase()); // ‚úÖ Now it's safe
}
```

---

### üîó **Union Types Questions**

**Q5: How do you work with union types safely?**

**Answer:** Use type narrowing to safely work with union types. TypeScript provides several ways to narrow types:

```typescript
function processId(id: string | number) {
  // Type narrowing with typeof
  if (typeof id === 'string') {
    return id.toUpperCase(); // id is string here
  } else {
    return id.toFixed(2);    // id is number here
  }
}

function processData(data: string[] | string) {
  // Type narrowing with Array.isArray
  if (Array.isArray(data)) {
    return data.join(', '); // data is string[] here
  } else {
    return data.trim();     // data is string here
  }
}
```

**Q6: What happens when you try to access a property that doesn't exist on all members of a union type?**

**Answer:** TypeScript only allows operations that are valid for ALL members of the union. You must use type narrowing to access type-specific properties.

```typescript
function printLength(value: string | number) {
  console.log(value.length); // ‚ùå Error: Property 'length' does not exist on type 'number'
  
  // Must narrow the type first
  if (typeof value === 'string') {
    console.log(value.length); // ‚úÖ Now it works
  }
}
```

---

### üèóÔ∏è **Functions Questions**

**Q7: When should you explicitly type function parameters and return values?**

**Answer:** 
- **Always type parameters** - TypeScript cannot infer parameter types
- **Usually let TypeScript infer return types** - unless you want to enforce a specific contract
- **Always type return values for public APIs** - for documentation and contract enforcement

```typescript
// ‚úÖ Good: Explicit parameters, inferred return
function add(a: number, b: number) {
  return a + b; // return type inferred as number
}

// ‚úÖ Good: Explicit return type for API contract
function fetchUser(id: string): Promise<User> {
  return fetch(`/api/users/${id}`).then(r => r.json());
}
```

**Q8: What is contextual typing in TypeScript?**

**Answer:** Contextual typing is when TypeScript infers the type of a function's parameters based on how the function is used.

```typescript
const names = ["Alice", "Bob", "Charlie"];

// TypeScript knows 'name' is string from the array context
names.forEach(name => {
  console.log(name.toUpperCase()); // No need to type 'name' parameter
});

// Same with array methods
const lengths = names.map(name => name.length); // returns number[]
```

---

### üì¶ **Object Types Questions**

**Q9: How do you handle optional properties in object types?**

**Answer:** Use the `?` operator for optional properties and always check for `undefined` before using them.

```typescript
interface User {
  name: string;
  email?: string; // Optional property
}

function greetUser(user: User) {
  console.log(`Hello, ${user.name}`);
  
  // Must check for undefined
  if (user.email !== undefined) {
    console.log(`Email: ${user.email}`);
  }
  
  // Or use optional chaining
  console.log(`Email length: ${user.email?.length ?? 0}`);
}
```

**Q10: What's the difference between `interface` and `type` aliases?**

**Answer:** 

| Feature | Interface | Type Alias |
|---------|-----------|------------|
| **Extension** | `extends` keyword | Intersection (`&`) |
| **Declaration Merging** | ‚úÖ Supported | ‚ùå Not supported |
| **Primitives** | ‚ùå Objects only | ‚úÖ Any type |
| **Union Types** | ‚ùå Cannot represent | ‚úÖ Can represent |

```typescript
// Interface extension
interface Animal {
  name: string;
}
interface Dog extends Animal {
  breed: string;
}

// Type alias intersection
type Animal = { name: string };
type Dog = Animal & { breed: string };

// Type aliases can represent unions (interfaces cannot)
type Status = "loading" | "success" | "error";
```

---

### üéØ **Type Assertions Questions**

**Q11: When and how should you use type assertions?**

**Answer:** Use type assertions when you know more about a type than TypeScript can infer, but use them sparingly and safely.

```typescript
// ‚úÖ Good use case: DOM elements
const canvas = document.getElementById('canvas') as HTMLCanvasElement;

// ‚úÖ Good use case: API responses (with runtime validation)
const user = JSON.parse(response) as User;

// ‚ùå Dangerous: Asserting unrelated types
const num = "hello" as number; // This will cause runtime errors!

// ‚úÖ Safe escape hatch: Use unknown as intermediate
const num = ("hello" as unknown) as number; // Still dangerous but explicit
```

**Q12: What is the non-null assertion operator and when should you use it?**

**Answer:** The `!` operator tells TypeScript that a value is definitely not `null` or `undefined`. Use it only when you're absolutely certain.

```typescript
function processElement(id: string) {
  const element = document.getElementById(id)!; // Assumes element exists
  element.style.color = 'red'; // No null check needed
}

// ‚ö†Ô∏è Dangerous if element doesn't exist - will cause runtime error
// ‚úÖ Better approach:
function processElementSafely(id: string) {
  const element = document.getElementById(id);
  if (element) {
    element.style.color = 'red';
  }
}
```

---

### üìù **Literal Types Questions**

**Q13: What are literal types and how are they useful?**

**Answer:** Literal types represent exact values rather than general types. They're useful for creating precise APIs and preventing typos.

```typescript
// String literal types
type Direction = "up" | "down" | "left" | "right";

function move(direction: Direction) {
  // TypeScript ensures only valid directions are passed
}

move("up");    // ‚úÖ Valid
move("north"); // ‚ùå Error: Argument of type '"north"' is not assignable

// Numeric literal types
type DiceRoll = 1 | 2 | 3 | 4 | 5 | 6;

function rollDice(): DiceRoll {
  return Math.floor(Math.random() * 6) + 1 as DiceRoll;
}
```

**Q14: What is the `as const` assertion and when do you use it?**

**Answer:** `as const` creates the most specific literal types possible and makes arrays/objects readonly.

```typescript
// Without as const
const colors = ["red", "green", "blue"]; // type: string[]

// With as const
const colors = ["red", "green", "blue"] as const; // type: readonly ["red", "green", "blue"]

// Useful for configuration objects
const config = {
  apiUrl: "https://api.example.com",
  timeout: 5000
} as const;
// config.apiUrl has type "https://api.example.com", not string
```

---

### üõ°Ô∏è **Null Safety Questions**

**Q15: What is `strictNullChecks` and why is it important?**

**Answer:** `strictNullChecks` prevents the "billion-dollar mistake" by making `null` and `undefined` explicit in the type system.

```typescript
// With strictNullChecks: false (dangerous)
let name: string = null; // No error, but dangerous!
name.toUpperCase(); // Runtime error!

// With strictNullChecks: true (safe)
let name: string | null = null; // Must be explicit about null
if (name !== null) {
  name.toUpperCase(); // Safe - TypeScript knows name is not null
}
```

**Q16: How do you handle null and undefined values safely?**

**Answer:** Use explicit checks, optional chaining, and nullish coalescing.

```typescript
interface User {
  name: string;
  email?: string;
}

function processUser(user: User | null) {
  // Null check
  if (user === null) return;
  
  // Optional chaining
  const emailLength = user.email?.length;
  
  // Nullish coalescing
  const displayEmail = user.email ?? "No email provided";
  
  // Type narrowing
  if (user.email !== undefined) {
    console.log(user.email.toUpperCase()); // Safe to use
  }
}
```

---

### üöÄ **Advanced Questions**

**Q17: What's the difference between `Array<T>` and `T[]` syntax?**

**Answer:** They're functionally identical, but `T[]` is more common for simple types, while `Array<T>` is preferred for complex generic scenarios.

```typescript
// Both are equivalent
let numbers1: number[] = [1, 2, 3];
let numbers2: Array<number> = [1, 2, 3];

// Array<T> is clearer with complex types
let users: Array<{ name: string; age: number }> = [];
// vs
let users: { name: string; age: number }[] = [];
```

**Q18: How does TypeScript handle array methods and type safety?**

**Answer:** TypeScript maintains type safety through array methods by inferring return types based on the array's element type.

```typescript
const numbers = [1, 2, 3, 4, 5];

const doubled = numbers.map(n => n * 2);        // number[]
const strings = numbers.map(n => n.toString()); // string[]
const evens = numbers.filter(n => n % 2 === 0); // number[]
const sum = numbers.reduce((a, b) => a + b, 0);  // number
```

---

### üí° **Best Practice Questions**

**Q19: What are the most important TypeScript compiler flags for type safety?**

**Answer:** 
- `"strict": true` - Enables all strict checks
- `"noImplicitAny": true` - Prevents implicit any types
- `"strictNullChecks": true` - Requires explicit null handling
- `"noImplicitReturns": true` - Ensures all code paths return a value

```json
{
  "compilerOptions": {
    "strict": true,
    "noImplicitAny": true,
    "strictNullChecks": true,
    "noImplicitReturns": true
  }
}
```

**Q20: How do you migrate JavaScript code to TypeScript gradually?**

**Answer:** 
1. Start with `allowJs: true` and `checkJs: false`
2. Rename `.js` files to `.ts` one by one
3. Add type annotations gradually
4. Enable stricter checks incrementally
5. Use `// @ts-ignore` sparingly for temporary fixes

```typescript
// Step 1: Basic conversion
function add(a, b) {  // Implicit any parameters
  return a + b;
}

// Step 2: Add parameter types
function add(a: number, b: number) {
  return a + b;  // Return type inferred
}

// Step 3: Explicit return type (optional)
function add(a: number, b: number): number {
  return a + b;
}
```

---

## Best Practices Summary

### ‚úÖ Do This
1. **Enable strict mode** in your `tsconfig.json`
2. **Let TypeScript infer types** when obvious
3. **Use explicit types** for function parameters and return values
4. **Prefer `unknown` over `any`** for truly unknown data
5. **Use union types** instead of `any` when you have multiple possibilities
6. **Handle null/undefined explicitly** with strict null checks
7. **Use type narrowing** to work safely with union types

### ‚ùå Avoid This
1. **Don't use `any`** unless absolutely necessary
2. **Don't over-annotate** obvious types
3. **Don't ignore TypeScript errors** - they usually indicate real problems
4. **Don't use non-null assertion (`!`)** unless you're certain
5. **Don't mix `bigint` and `number`** without explicit conversion

---

