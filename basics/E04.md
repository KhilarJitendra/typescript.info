# TypeScript Functions: Essential Guide

Learn how to write type-safe functions in TypeScript.

## Table of Contents
1. [Function Type Expressions](#function-type-expressions)
2. [Generic Functions](#generic-functions)
3. [Optional Parameters](#optional-parameters)
4. [Function Overloads](#function-overloads)
5. [Special Return Types](#special-return-types)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. Function Type Expressions

Define function types using arrow syntax:

```typescript
// Function type expression
type GreetFunction = (name: string) => string;

function greeter(fn: GreetFunction) {
  console.log(fn("World"));
}

function sayHello(name: string): string {
  return `Hello, ${name}!`;
}

greeter(sayHello); // ✅ Works
```

### Type Aliases for Functions
```typescript
// Common function types
type EventHandler = (event: MouseEvent) => void;
type Validator = (input: string) => boolean;
type Transformer<T, U> = (input: T) => U;

// Usage
const onClick: EventHandler = (event) => {
  console.log("Clicked!");
};

const isEmail: Validator = (input) => {
  return input.includes("@");
};
```

---

## 2. Generic Functions

Create reusable functions that work with multiple types:

```typescript
// Without generics - loses type information
function firstElementBad(arr: any[]): any {
  return arr[0]; // Returns any
}

// With generics - preserves type information
function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

const s = firstElement(["a", "b", "c"]);    // string | undefined
const n = firstElement([1, 2, 3]);          // number | undefined
```

### Multiple Type Parameters
```typescript
function map<Input, Output>(
  arr: Input[], 
  func: (arg: Input) => Output
): Output[] {
  return arr.map(func);
}

const numbers = map(["1", "2", "3"], (s) => parseInt(s)); // number[]
```

### Generic Constraints
```typescript
// Constrain T to types with length property
function longest<T extends { length: number }>(a: T, b: T): T {
  return a.length >= b.length ? a : b;
}

longest("hello", "world");     // ✅ strings have length
longest([1, 2], [1, 2, 3]);   // ✅ arrays have length
// longest(10, 20);           // ❌ numbers don't have length
```

---

## 3. Optional Parameters

### Basic Optional Parameters
```typescript
function greet(name: string, greeting?: string): string {
  return `${greeting || "Hello"}, ${name}!`;
}

greet("Alice");              // "Hello, Alice!"
greet("Bob", "Hi");          // "Hi, Bob!"
```

### Default Parameters
```typescript
function createUser(name: string, age: number = 18, active: boolean = true) {
  return { name, age, active };
}

createUser("Alice");                    // { name: "Alice", age: 18, active: true }
createUser("Bob", 25);                  // { name: "Bob", age: 25, active: true }
createUser("Charlie", 30, false);       // { name: "Charlie", age: 30, active: false }
```

### ⚠️ Optional Parameters in Callbacks
```typescript
// ❌ Don't make callback parameters optional
function forEach(arr: any[], callback: (item: any, index?: number) => void) {
  // This suggests index might not be provided
}

// ✅ Better: Don't make them optional
function forEach(arr: any[], callback: (item: any, index: number) => void) {
  // Callers can ignore parameters they don't need
}

// Usage - both work fine:
forEach([1, 2, 3], (item) => console.log(item));           // Ignore index
forEach([1, 2, 3], (item, index) => console.log(item, index)); // Use both
```

---

## 4. Function Overloads

Define multiple function signatures:

```typescript
// Overload signatures
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;

// Implementation signature
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}

const d1 = makeDate(12345678);        // ✅ Uses first overload
const d2 = makeDate(5, 5, 5);         // ✅ Uses second overload
// const d3 = makeDate(1, 3);         // ❌ No matching overload
```

### When to Use Overloads vs Union Types
```typescript
// ❌ Overloads can be restrictive
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) { return x.length; }

// This doesn't work:
// len(Math.random() > 0.5 ? "hello" : [1, 2, 3]); // ❌ Error

// ✅ Better: Use union types when possible
function lenBetter(x: string | any[]): number {
  return x.length;
}

lenBetter(Math.random() > 0.5 ? "hello" : [1, 2, 3]); // ✅ Works
```

---

## 5. Special Return Types

### void Type
```typescript
// Functions that don't return a value
function logMessage(message: string): void {
  console.log(message);
  // No return statement needed
}

// ⚠️ void ≠ undefined
function returnsVoid(): void {
  return undefined; // ✅ OK
}

function returnsUndefined(): undefined {
  return undefined; // Must explicitly return undefined
}
```

### never Type
```typescript
// Functions that never return
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {
    console.log("Running forever...");
  }
}
```

### unknown Type
```typescript
// Safe alternative to any
function safeParse(json: string): unknown {
  return JSON.parse(json);
}

const data = safeParse('{"name": "Alice"}');

// Must check type before using
if (typeof data === "object" && data !== null && "name" in data) {
  console.log((data as { name: string }).name);
}
```

---

## Key Interview Questions

### Q1: What's the difference between function type expressions and call signatures?
**Answer:** Function type expressions use arrow syntax, call signatures use object syntax:

```typescript
// Function type expression
type Handler = (event: Event) => void;

// Call signature (for functions with properties)
type DescribableFunction = {
  description: string;
  (arg: number): boolean;
};
```

### Q2: How do generic functions work and when should you use them?
**Answer:** Generics create reusable functions that preserve type information:

```typescript
// Generic preserves type relationship
function identity<T>(arg: T): T {
  return arg;
}

const str = identity("hello");  // string
const num = identity(42);       // number
```

### Q3: What's wrong with making callback parameters optional?
**Answer:** It creates confusion about whether the parameter will actually be provided:

```typescript
// ❌ Misleading
function forEach(arr: any[], callback: (item: any, index?: number) => void) {
  // Implementation always provides index, so why optional?
}

// ✅ Clear
function forEach(arr: any[], callback: (item: any, index: number) => void) {
  // Callers can ignore parameters they don't need
}
```

### Q4: When should you use function overloads vs union types?
**Answer:** Prefer union types when possible - they're more flexible:

```typescript
// ✅ Union type - more flexible
function process(input: string | number): string {
  return String(input);
}

// Only use overloads when you need different return types
function createElement(tag: "div"): HTMLDivElement;
function createElement(tag: "span"): HTMLSpanElement;
function createElement(tag: string): HTMLElement;
```

### Q5: What's the difference between `void`, `undefined`, and `never`?
**Answer:**
- `void`: Function doesn't return a meaningful value
- `undefined`: Function explicitly returns undefined
- `never`: Function never returns (throws error or infinite loop)

```typescript
function logMessage(): void { console.log("hi"); }      // Returns undefined implicitly
function getUndefined(): undefined { return undefined; } // Must return undefined
function throwError(): never { throw new Error(); }     // Never returns
```

---

## Best Practices

### ✅ Do This
1. **Use generics** to create reusable, type-safe functions
2. **Let TypeScript infer return types** when obvious
3. **Be explicit with parameter types** - always required
4. **Use union types over overloads** when possible
5. **Use `unknown` instead of `any`** for safer typing

### ❌ Avoid This
1. **Don't make callback parameters optional** unless you won't provide them
2. **Don't overuse function overloads** - prefer union types
3. **Don't use `any` return types** - use `unknown` for safety
4. **Don't create unnecessary generic parameters**
5. **Don't ignore TypeScript's type inference**

---

## Next Steps
- **Objects**: Complex object type patterns
- **Classes**: Object-oriented programming with TypeScript
- **Advanced Types**: Conditional types and mapped types
- **Modules**: Organizing TypeScript applications