# TypeScript Functions: The Complete Guide to Type-Safe Function Programming

Functions are the heart of any JavaScript application, and TypeScript elevates them with powerful type safety features. This comprehensive guide will teach you everything you need to know about TypeScript functions - from basic type expressions to advanced generic patterns.

## Table of Contents
1. [Function Type Expressions](#function-type-expressions)
2. [Call and Construct Signatures](#call-and-construct-signatures)
3. [Generic Functions](#generic-functions)
4. [Function Overloads](#function-overloads)
5. [Optional Parameters](#optional-parameters)
6. [The this Context](#the-this-context)
7. [Special Return Types](#special-return-types)
8. [Rest Parameters and Spread Arguments](#rest-parameters-and-spread-arguments)
9. [Parameter Destructuring](#parameter-destructuring)
10. [Function Assignability](#function-assignability)
11. [Interview Questions & Answers](#interview-questions--answers)

---

## 1. Function Type Expressions

Function type expressions are the simplest way to describe function types in TypeScript. They use arrow function syntax to define the shape of a function.

### Basic Function Type Expressions

```typescript
// Function type expression: (parameter: type) => returnType
function greeter(fn: (a: string) => void) {
  fn("Hello, World");
}

function printToConsole(s: string) {
  console.log(s);
}

greeter(printToConsole); // ✅ Works - printToConsole matches the type
```

### Key Syntax Rules

```typescript
// ✅ Correct: Parameter name is required
type Handler = (message: string) => void;

// ❌ Wrong: This means "parameter named 'string' of type any"
type BadHandler = (string) => void;

// ✅ Multiple parameters
type Calculator = (a: number, b: number) => number;

// ✅ No parameters
type SimpleAction = () => void;
```

### Using Type Aliases for Function Types

```typescript
// Define reusable function types
type GreetFunction = (name: string) => void;
type ValidatorFunction = (input: string) => boolean;
type TransformFunction<T, U> = (input: T) => U;

// Use in function parameters
function processInput(
  value: string,
  validator: ValidatorFunction,
  transformer: TransformFunction<string, number>
) {
  if (validator(value)) {
    return transformer(value);
  }
  throw new Error("Invalid input");
}

// Usage
const isNumeric: ValidatorFunction = (input) => /^\d+$/.test(input);
const toNumber: TransformFunction<string, number> = (input) => parseInt(input);

const result = processInput("123", isNumeric, toNumber); // result: number
```

### Real-World Examples

```typescript
// Event handler types
type ClickHandler = (event: MouseEvent) => void;
type ChangeHandler = (value: string) => void;

// API callback types
type SuccessCallback<T> = (data: T) => void;
type ErrorCallback = (error: Error) => void;
type ApiCallback<T> = {
  onSuccess: SuccessCallback<T>;
  onError: ErrorCallback;
};

// Higher-order function types
type Middleware<T> = (input: T, next: (result: T) => void) => void;
type Reducer<State, Action> = (state: State, action: Action) => State;
```

---

## 2. Call and Construct Signatures

Sometimes functions need properties or can be called with `new`. TypeScript provides call and construct signatures for these scenarios.

### Call Signatures

Call signatures allow you to describe functions that have properties:

```typescript
// Function with properties
type DescribableFunction = {
  description: string;
  (someArg: number): boolean; // Call signature
};

function doSomething(fn: DescribableFunction) {
  console.log(fn.description + " returned " + fn(6));
}

// Creating a function that matches
function myFunc(someArg: number): boolean {
  return someArg > 3;
}
myFunc.description = "checks if number is greater than 3";

doSomething(myFunc); // ✅ Works
```

### Construct Signatures

Construct signatures describe functions that can be called with `new`:

```typescript
// Constructor function type
type SomeConstructor = {
  new (s: string): SomeObject;
};

function createInstance(ctor: SomeConstructor) {
  return new ctor("hello");
}

// Example with a class
class MyClass {
  constructor(public value: string) {}
}

const instance = createInstance(MyClass); // instance: MyClass
```

### Combined Call and Construct Signatures

```typescript
// Functions that work both ways (like Date)
interface CallOrConstruct {
  (n?: number): string;        // Call signature
  new (s: string): Date;       // Construct signature
}

function flexibleFunction(ctor: CallOrConstruct) {
  // Called as function
  console.log(ctor(10));       // Returns string
  
  // Called as constructor
  console.log(new ctor("10")); // Returns Date
}

// Date object fits this pattern
flexibleFunction(Date);
```

### Practical Examples

```typescript
// jQuery-style library function
interface JQuery {
  (selector: string): JQueryObject;     // Call as function
  new (element: HTMLElement): JQueryObject; // Call as constructor
  version: string;                      // Property
}

// Factory function with metadata
interface ComponentFactory {
  (props: any): Component;              // Create component
  new (props: any): Component;          // Instantiate component
  displayName: string;                  // Component name
  defaultProps: any;                    // Default properties
}

// Error constructor pattern
interface ErrorConstructor {
  (message?: string): Error;            // Error("message")
  new (message?: string): Error;        // new Error("message")
  prototype: Error;                     // Error prototype
}
```

---

## 3. Generic Functions

Generics allow you to write functions that work with multiple types while maintaining type safety.

### Basic Generic Functions

```typescript
// Without generics - loses type information
function firstElementBad(arr: any[]): any {
  return arr[0]; // Returns any - not helpful!
}

// With generics - preserves type information
function firstElement<T>(arr: T[]): T | undefined {
  return arr[0];
}

// Usage with type inference
const s = firstElement(["a", "b", "c"]);    // s: string | undefined
const n = firstElement([1, 2, 3]);          // n: number | undefined
const u = firstElement([]);                 // u: undefined
```

### Multiple Type Parameters

```typescript
// Generic map function
function map<Input, Output>(
  arr: Input[], 
  func: (arg: Input) => Output
): Output[] {
  return arr.map(func);
}

// TypeScript infers both Input and Output types
const parsed = map(["1", "2", "3"], (n) => parseInt(n));
// parsed: number[]

const lengths = map(["hello", "world"], (s) => s.length);
// lengths: number[]
```

### Generic Constraints

Use `extends` to limit what types can be used:

```typescript
// Constraint: T must have a length property
function longest<T extends { length: number }>(a: T, b: T): T {
  if (a.length >= b.length) {
    return a;
  } else {
    return b;
  }
}

// Works with arrays
const longerArray = longest([1, 2], [1, 2, 3]); // number[]

// Works with strings
const longerString = longest("alice", "bob");    // "alice" | "bob"

// ❌ Error: numbers don't have length
// const notOK = longest(10, 100);
```

### Advanced Generic Patterns

```typescript
// Keyof constraint
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30, city: "NYC" };
const name = getProperty(person, "name");     // string
const age = getProperty(person, "age");       // number
// const invalid = getProperty(person, "invalid"); // ❌ Error

// Conditional types in generics
type ApiResponse<T> = T extends string 
  ? { message: T } 
  : { data: T };

function processApiResponse<T>(input: T): ApiResponse<T> {
  if (typeof input === "string") {
    return { message: input } as ApiResponse<T>;
  }
  return { data: input } as ApiResponse<T>;
}
```

### Generic Best Practices

```typescript
// ✅ Good: Push type parameters down
function firstElement1<T>(arr: T[]): T | undefined {
  return arr[0];
}

// ❌ Bad: Unnecessary constraint
function firstElement2<T extends any[]>(arr: T): any {
  return arr[0];
}

// ✅ Good: Use fewer type parameters
function filter<T>(arr: T[], func: (arg: T) => boolean): T[] {
  return arr.filter(func);
}

// ❌ Bad: Unnecessary extra type parameter
function filterBad<T, Func extends (arg: T) => boolean>(
  arr: T[], 
  func: Func
): T[] {
  return arr.filter(func);
}

// ✅ Good: Type parameter used multiple times
function swap<T>(a: T, b: T): [T, T] {
  return [b, a];
}

// ❌ Bad: Type parameter used only once
function greetBad<T extends string>(s: T): void {
  console.log("Hello, " + s);
}

// ✅ Better: No need for generics
function greet(s: string): void {
  console.log("Hello, " + s);
}
```

---

## 4. Function Overloads

Function overloads allow you to define multiple function signatures for different argument patterns.

### Basic Function Overloads

```typescript
// Overload signatures
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;

// Implementation signature (not callable directly)
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  if (d !== undefined && y !== undefined) {
    return new Date(y, mOrTimestamp, d);
  } else {
    return new Date(mOrTimestamp);
  }
}

// Usage
const d1 = makeDate(12345678);        // ✅ Uses first overload
const d2 = makeDate(5, 5, 5);         // ✅ Uses second overload
// const d3 = makeDate(1, 3);         // ❌ Error: No matching overload
```

### Overload Rules and Gotchas

```typescript
// ❌ Common mistake: Implementation signature is not callable
function fn(x: string): void;
function fn() {
  // Implementation
}

// fn();  // ❌ Error: Expected 1 argument, but got 0

// ✅ Correct: Implementation must be compatible with all overloads
function fn2(x: string): void;
function fn2(x: string, y: number): void;
function fn2(x: string, y?: number): void {
  // Implementation handles both cases
}
```

### When to Use Overloads vs Union Types

```typescript
// ❌ Overloads can be restrictive
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) {
  return x.length;
}

// This doesn't work with overloads:
// len(Math.random() > 0.5 ? "hello" : [0]); // ❌ Error

// ✅ Better: Use union types when possible
function lenBetter(x: any[] | string): number {
  return x.length;
}

// Now this works:
lenBetter(Math.random() > 0.5 ? "hello" : [0]); // ✅ Works
```

### Practical Overload Examples

```typescript
// DOM element creation
function createElement(tagName: "div"): HTMLDivElement;
function createElement(tagName: "span"): HTMLSpanElement;
function createElement(tagName: "input"): HTMLInputElement;
function createElement(tagName: string): HTMLElement;
function createElement(tagName: string): HTMLElement {
  return document.createElement(tagName);
}

// Usage with precise return types
const div = createElement("div");     // HTMLDivElement
const span = createElement("span");   // HTMLSpanElement
const input = createElement("input"); // HTMLInputElement
const custom = createElement("custom-element"); // HTMLElement

// API client with different response types
interface ApiClient {
  get(url: "/users"): Promise<User[]>;
  get(url: "/user", id: string): Promise<User>;
  get(url: string): Promise<unknown>;
}

// Event listener overloads
interface EventTarget {
  addEventListener(type: "click", listener: (e: MouseEvent) => void): void;
  addEventListener(type: "keydown", listener: (e: KeyboardEvent) => void): void;
  addEventListener(type: string, listener: (e: Event) => void): void;
}
```

---

## 5. Optional Parameters

Optional parameters provide flexibility in function calls while maintaining type safety.

### Basic Optional Parameters

```typescript
// Optional parameter with ?
function greet(name: string, greeting?: string): string {
  if (greeting) {
    return `${greeting}, ${name}!`;
  }
  return `Hello, ${name}!`;
}

greet("Alice");              // ✅ "Hello, Alice!"
greet("Bob", "Hi");          // ✅ "Hi, Bob!"
greet("Charlie", undefined); // ✅ "Hello, Charlie!"
```

### Default Parameters

```typescript
// Default parameter values
function createUser(name: string, age: number = 18, active: boolean = true) {
  return { name, age, active };
}

createUser("Alice");                    // { name: "Alice", age: 18, active: true }
createUser("Bob", 25);                  // { name: "Bob", age: 25, active: true }
createUser("Charlie", 30, false);       // { name: "Charlie", age: 30, active: false }

// TypeScript infers the parameter types from defaults
function processData(data: string, options = { strict: true, timeout: 5000 }) {
  // options has type { strict: boolean; timeout: number; }
  if (options.strict) {
    // Strict processing
  }
}
```

### Optional Parameters in Callbacks

```typescript
// ❌ Common mistake: Making callback parameters optional
function myForEach(arr: any[], callback: (arg: any, index?: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

// This creates confusion:
myForEach([1, 2, 3], (a, i) => {
  console.log(i?.toFixed()); // i might be undefined? (It's not!)
});

// ✅ Better: Don't make callback parameters optional
function myForEachBetter(arr: any[], callback: (arg: any, index: number) => void) {
  for (let i = 0; i < arr.length; i++) {
    callback(arr[i], i);
  }
}

// Now it's clear:
myForEachBetter([1, 2, 3], (a, i) => {
  console.log(i.toFixed()); // i is definitely number
});

// Callers can ignore parameters they don't need:
myForEachBetter([1, 2, 3], (a) => console.log(a)); // ✅ Works fine
```

### Advanced Optional Parameter Patterns

```typescript
// Optional parameters with type guards
function processUser(
  user: { name: string; email?: string; phone?: string }
) {
  console.log(`Processing user: ${user.name}`);
  
  if (user.email) {
    // user.email is definitely string here
    sendEmail(user.email);
  }
  
  if (user.phone) {
    // user.phone is definitely string here
    sendSMS(user.phone);
  }
}

// Configuration objects with optional properties
interface ApiConfig {
  baseUrl: string;
  timeout?: number;
  retries?: number;
  headers?: Record<string, string>;
}

function createApiClient(config: ApiConfig) {
  const defaultConfig = {
    timeout: 5000,
    retries: 3,
    headers: {},
    ...config
  };
  
  return {
    get: (url: string) => fetch(`${defaultConfig.baseUrl}${url}`),
    // ... other methods
  };
}
```

---

## 6. The this Context

TypeScript provides powerful tools for working with JavaScript's `this` context in a type-safe way.

### Declaring this in Functions

```typescript
interface User {
  id: number;
  name: string;
  admin: boolean;
}

interface DB {
  filterUsers(filter: (this: User) => boolean): User[];
}

const db: DB = {
  filterUsers(filter) {
    const users: User[] = [
      { id: 1, name: "Alice", admin: true },
      { id: 2, name: "Bob", admin: false }
    ];
    
    return users.filter(function(user) {
      return filter.call(user); // Call filter with user as 'this'
    });
  }
};

// Usage with explicit this typing
const admins = db.filterUsers(function(this: User) {
  return this.admin; // 'this' is typed as User
});
```

### this vs Arrow Functions

```typescript
interface EventHandler {
  handleClick(this: HTMLElement, event: MouseEvent): void;
}

const handler: EventHandler = {
  // ✅ Function declaration preserves 'this'
  handleClick: function(this: HTMLElement, event: MouseEvent) {
    console.log(this.tagName); // 'this' is HTMLElement
  }
};

// ❌ Arrow functions capture lexical 'this'
const badHandler: EventHandler = {
  handleClick: (event: MouseEvent) => {
    // console.log(this.tagName); // Error: 'this' is not HTMLElement
  }
};
```

### Class Methods and this

```typescript
class Calculator {
  private result: number = 0;
  
  add(value: number): this {
    this.result += value;
    return this; // Method chaining
  }
  
  multiply(value: number): this {
    this.result *= value;
    return this;
  }
  
  getValue(): number {
    return this.result;
  }
  
  // Method that can be safely extracted
  getValueSafe = (): number => {
    return this.result; // Arrow function preserves 'this'
  }
}

const calc = new Calculator();
const result = calc.add(5).multiply(2).getValue(); // Method chaining works

// Safe extraction
const getValue = calc.getValueSafe;
console.log(getValue()); // Works correctly
```

### this Parameters in Callbacks

```typescript
// jQuery-style event handling
interface JQueryElement {
  on(event: string, handler: (this: HTMLElement, event: Event) => void): void;
}

declare const $: (selector: string) => JQueryElement;

$(".button").on("click", function(this: HTMLElement, event: Event) {
  // 'this' is the clicked HTML element
  this.classList.add("clicked");
});

// React-style event handling
interface Component {
  setState(state: any): void;
  handleClick(this: Component, event: MouseEvent): void;
}

class MyComponent implements Component {
  setState(state: any) {
    // Update component state
  }
  
  // Bound method for event handling
  handleClick = (event: MouseEvent) => {
    this.setState({ clicked: true }); // 'this' is always MyComponent
  }
}
```

---

## 7. Special Return Types

TypeScript has several special types that are particularly relevant for function return types.

### void Type

```typescript
// Functions that don't return a value
function logMessage(message: string): void {
  console.log(message);
  // No return statement needed
}

function processData(data: any[]): void {
  data.forEach(item => console.log(item));
  return; // Explicit return with no value is OK
}

// ⚠️ Important: void ≠ undefined
function returnsVoid(): void {
  return undefined; // ✅ OK
}

function returnsUndefined(): undefined {
  return undefined; // Must explicitly return undefined
}
```

### Contextual void Behavior

```typescript
// Contextual typing allows void functions to return values
type VoidFunction = () => void;

const f1: VoidFunction = () => {
  return true; // ✅ OK - return value is ignored
};

const f2: VoidFunction = () => true; // ✅ OK

// The return value is typed as void
const result = f1(); // result: void

// This enables array methods to work:
const numbers = [1, 2, 3];
const results: number[] = [];

numbers.forEach(n => results.push(n)); // push returns number, but forEach expects void
```

### never Type

```typescript
// Functions that never return
function throwError(message: string): never {
  throw new Error(message);
}

function infiniteLoop(): never {
  while (true) {
    console.log("Running forever...");
  }
}

// never in control flow
function processValue(value: string | number): string {
  if (typeof value === "string") {
    return value.toUpperCase();
  } else if (typeof value === "number") {
    return value.toString();
  } else {
    // value is never here - all cases handled
    return throwError("Unexpected value type");
  }
}
```

### unknown Type

```typescript
// Safe alternative to any
function safeParse(json: string): unknown {
  return JSON.parse(json);
}

// Must check type before using
const data = safeParse('{"name": "Alice"}');

if (typeof data === "object" && data !== null && "name" in data) {
  console.log((data as { name: string }).name);
}

// Generic function returning unknown
function fetchData<T = unknown>(url: string): Promise<T> {
  return fetch(url).then(response => response.json());
}

// Usage with type assertion
interface User {
  name: string;
  email: string;
}

const user = await fetchData<User>("/api/user");
console.log(user.name); // Type-safe after assertion
```

### object vs Object vs {}

```typescript
// object: any non-primitive value
function processObject(obj: object): void {
  // obj can be any object, array, function, etc.
  console.log(typeof obj); // "object" or "function"
}

processObject({});           // ✅ OK
processObject([]);           // ✅ OK
processObject(() => {});     // ✅ OK
// processObject("string");  // ❌ Error: string is primitive

// Object: rarely used global type
function badFunction(obj: Object): void {
  // Don't use this - use object instead
}

// {}: empty object type (also avoid)
function emptyObject(obj: {}): void {
  // obj can be anything except null/undefined
}
```

### Function Type

```typescript
// Global Function type (avoid when possible)
function callAnyFunction(fn: Function): any {
  return fn(1, 2, 3); // Unsafe - returns any
}

// ✅ Better: Specific function type
function callSpecificFunction(fn: (a: number, b: number) => number): number {
  return fn(1, 2);
}

// ✅ Best: Generic function type
function callGenericFunction<T extends (...args: any[]) => any>(
  fn: T,
  ...args: Parameters<T>
): ReturnType<T> {
  return fn(...args);
}
```

---

## 8. Rest Parameters and Spread Arguments

Rest parameters and spread syntax provide flexible ways to handle variable numbers of arguments.

### Rest Parameters

```typescript
// Basic rest parameters
function multiply(n: number, ...m: number[]): number[] {
  return m.map((x) => n * x);
}

const results = multiply(10, 1, 2, 3, 4); // [10, 20, 30, 40]

// Rest parameters with different types
function logMessages(level: string, ...messages: string[]): void {
  messages.forEach(msg => console.log(`[${level}] ${msg}`));
}

logMessages("INFO", "App started", "Database connected", "Ready to serve");

// Generic rest parameters
function combineArrays<T>(...arrays: T[][]): T[] {
  return arrays.flat();
}

const combined = combineArrays([1, 2], [3, 4], [5, 6]); // number[]
```

### Spread Arguments

```typescript
// Spreading arrays into function calls
const numbers = [1, 2, 3];
Math.max(...numbers); // Equivalent to Math.max(1, 2, 3)

// ⚠️ TypeScript array mutability issue
const args = [8, 5];
// Math.atan2(...args); // ❌ Error: spread argument must be tuple or rest parameter

// ✅ Solutions:
// 1. Use const assertion
const args1 = [8, 5] as const;
Math.atan2(...args1); // ✅ OK

// 2. Use tuple type
const args2: [number, number] = [8, 5];
Math.atan2(...args2); // ✅ OK

// 3. Use rest parameter function
function callAtan2(...args: [number, number]) {
  return Math.atan2(...args);
}
```

### Advanced Rest Parameter Patterns

```typescript
// Rest parameters with tuple types
function processData(
  action: string,
  ...data: [string, number] | [string, number, boolean]
): void {
  const [name, age, active = true] = data;
  console.log(`${action}: ${name}, age ${age}, active: ${active}`);
}

processData("create", "Alice", 30);        // OK
processData("update", "Bob", 25, false);   // OK
// processData("delete", "Charlie");       // ❌ Error

// Generic rest with constraints
function createTuple<T extends readonly unknown[]>(...elements: T): T {
  return elements;
}

const tuple = createTuple("hello", 42, true); // ["hello", 42, true]

// Rest parameters in method signatures
interface Logger {
  log(level: "info" | "warn" | "error", ...messages: string[]): void;
}

class ConsoleLogger implements Logger {
  log(level: "info" | "warn" | "error", ...messages: string[]): void {
    const timestamp = new Date().toISOString();
    console.log(`[${timestamp}] [${level.toUpperCase()}]`, ...messages);
  }
}
```

---

## 9. Parameter Destructuring

Parameter destructuring allows you to unpack objects and arrays directly in function parameters.

### Object Destructuring

```typescript
// Basic object destructuring
function greetUser({ name, age }: { name: string; age: number }): string {
  return `Hello ${name}, you are ${age} years old`;
}

greetUser({ name: "Alice", age: 30 });

// Using type aliases for cleaner syntax
type User = { name: string; age: number; email?: string };

function processUser({ name, age, email }: User): void {
  console.log(`Processing ${name} (${age})`);
  if (email) {
    console.log(`Email: ${email}`);
  }
}

// Default values in destructuring
function createConfig({
  host = "localhost",
  port = 3000,
  ssl = false
}: {
  host?: string;
  port?: number;
  ssl?: boolean;
} = {}): Config {
  return { host, port, ssl };
}

createConfig();                           // Uses all defaults
createConfig({ port: 8080 });             // Override port only
createConfig({ host: "example.com", ssl: true }); // Override multiple
```

### Array Destructuring

```typescript
// Basic array destructuring
function processCoordinates([x, y]: [number, number]): string {
  return `Point at (${x}, ${y})`;
}

processCoordinates([10, 20]);

// Rest elements in destructuring
function processNumbers([first, second, ...rest]: number[]): void {
  console.log(`First: ${first}, Second: ${second}`);
  console.log(`Remaining: ${rest.join(", ")}`);
}

processNumbers([1, 2, 3, 4, 5]);

// Optional elements
function processOptionalCoords([x, y, z]: [number, number, number?]): void {
  console.log(`2D: (${x}, ${y})`);
  if (z !== undefined) {
    console.log(`3D: (${x}, ${y}, ${z})`);
  }
}

processOptionalCoords([1, 2]);     // OK
processOptionalCoords([1, 2, 3]);  // OK
```

### Nested Destructuring

```typescript
// Complex nested destructuring
interface ApiResponse {
  data: {
    user: {
      profile: {
        name: string;
        avatar: string;
      };
      settings: {
        theme: "light" | "dark";
        notifications: boolean;
      };
    };
  };
  meta: {
    timestamp: string;
    version: string;
  };
}

function processApiResponse({
  data: {
    user: {
      profile: { name, avatar },
      settings: { theme, notifications }
    }
  },
  meta: { timestamp }
}: ApiResponse): void {
  console.log(`User: ${name}`);
  console.log(`Theme: ${theme}`);
  console.log(`Notifications: ${notifications ? "on" : "off"}`);
  console.log(`Last updated: ${timestamp}`);
}
```

### Destructuring with Generics

```typescript
// Generic destructuring
function extractFields<T, K extends keyof T>(
  obj: T,
  ...keys: K[]
): Pick<T, K> {
  const result = {} as Pick<T, K>;
  for (const key of keys) {
    result[key] = obj[key];
  }
  return result;
}

const user = { name: "Alice", age: 30, email: "alice@example.com", city: "NYC" };
const userInfo = extractFields(user, "name", "email"); // { name: string; email: string; }

// Destructuring in generic functions
function mapObject<T, U>(
  obj: Record<string, T>,
  mapper: ({ key, value }: { key: string; value: T }) => U
): Record<string, U> {
  const result: Record<string, U> = {};
  for (const [key, value] of Object.entries(obj)) {
    result[key] = mapper({ key, value });
  }
  return result;
}

const numbers = { a: 1, b: 2, c: 3 };
const doubled = mapObject(numbers, ({ value }) => value * 2);
// doubled: { a: number; b: number; c: number; }
```

---

## 10. Function Assignability

Understanding when one function type can be assigned to another is crucial for TypeScript mastery.

### Basic Assignability Rules

```typescript
// Functions with fewer parameters can be assigned to functions with more
type Handler1 = (a: string) => void;
type Handler2 = (a: string, b: number) => void;

const fn1: Handler1 = (a) => console.log(a);
const fn2: Handler2 = fn1; // ✅ OK - fn1 can ignore the second parameter

// This is why array methods work:
const numbers = [1, 2, 3];
numbers.forEach((value, index, array) => console.log(value)); // All parameters
numbers.forEach((value, index) => console.log(value));        // Ignore array
numbers.forEach((value) => console.log(value));               // Ignore index and array
```

### Return Type Assignability

```typescript
// Return types must be assignable
type ReturnsString = () => string;
type ReturnsStringOrNumber = () => string | number;

const getString: ReturnsString = () => "hello";
const getStringOrNumber: ReturnsStringOrNumber = getString; // ✅ OK - string is assignable to string | number

// But not the reverse:
const getStringOrNumber2: ReturnsStringOrNumber = () => Math.random() > 0.5 ? "hello" : 42;
// const getString2: ReturnsString = getStringOrNumber2; // ❌ Error - string | number not assignable to string
```

### void Return Type Special Behavior

```typescript
// void return type is special - it ignores actual return values
type VoidFunction = () => void;

// These are all valid:
const f1: VoidFunction = () => {
  return true; // Return value ignored
};

const f2: VoidFunction = () => true; // Return value ignored

const f3: VoidFunction = function() {
  return "hello"; // Return value ignored
};

// When called, the result is always void
const result1 = f1(); // result1: void
const result2 = f2(); // result2: void

// This enables array methods:
const src = [1, 2, 3];
const dst: number[] = [];

// forEach expects () => void, but push returns number
src.forEach(el => dst.push(el)); // ✅ Works because return value is ignored
```

### Literal Function Definitions vs Contextual Typing

```typescript
// Literal function definitions with void must not return anything
function literalVoid(): void {
  // return true; // ❌ Error in literal function definition
}

const literalVoid2 = function(): void {
  // return true; // ❌ Error in literal function definition
};

// But contextual typing is different:
type VoidFunc = () => void;
const contextualVoid: VoidFunc = () => {
  return true; // ✅ OK in contextual typing
};
```

### Generic Function Assignability

```typescript
// Generic functions and assignability
type GenericFunction<T> = (arg: T) => T;
type StringFunction = (arg: string) => string;

const identity = <T>(arg: T): T => arg;
const stringIdentity: StringFunction = identity; // ✅ OK - generic can be specialized

// Contravariance in function parameters
type EventHandler<T> = (event: T) => void;

interface MouseEvent { x: number; y: number; }
interface ClickEvent extends MouseEvent { button: number; }

const handleMouse: EventHandler<MouseEvent> = (event) => {
  console.log(`Mouse at ${event.x}, ${event.y}`);
};

const handleClick: EventHandler<ClickEvent> = handleMouse; // ✅ OK - MouseEvent handler can handle ClickEvent
```

---

## Interview Questions & Answers

### 🎯 **Function Type Expressions**

**Q1: What's the difference between these two function type expressions?**
```typescript
type Handler1 = (message: string) => void;
type Handler2 = (string) => void;
```

**Answer:** `Handler1` defines a function with a parameter named `message` of type `string`. `Handler2` defines a function with a parameter named `string` of type `any` (implicit). Parameter names are required in function type expressions, and omitting the type annotation defaults to `any`.

**Q2: How do you create a reusable function type that can work with different return types?**

**Answer:** Use generics in type aliases:

```typescript
type AsyncHandler<T> = (input: string) => Promise<T>;
type Transformer<Input, Output> = (input: Input) => Output;

// Usage
const parseJson: AsyncHandler<any> = async (json) => JSON.parse(json);
const toString: Transformer<number, string> = (num) => num.toString();
```

---

### 🏗️ **Call and Construct Signatures**

**Q3: What are call signatures and when would you use them?**

**Answer:** Call signatures describe functions that have properties. They're useful for functions that need metadata or configuration:

```typescript
type LoggerFunction = {
  (message: string): void;  // Call signature
  level: "info" | "warn" | "error";  // Property
};

const logger: LoggerFunction = Object.assign(
  (message: string) => console.log(message),
  { level: "info" as const }
);
```

**Q4: How do construct signatures work with the Date object?**

**Answer:** The Date object can be both called as a function and constructed with `new`:

```typescript
interface DateConstructor {
  (): string;              // Date() returns string
  new(): Date;             // new Date() returns Date instance
  new(value: number): Date; // new Date(timestamp)
}

// Date fits this pattern:
const dateString = Date();     // string
const dateObject = new Date(); // Date instance
```

---

### 🔧 **Generic Functions**

**Q5: What's wrong with this generic function and how would you fix it?**
```typescript
function process<T extends any[]>(arr: T) {
  return arr[0];
}
```

**Answer:** The constraint `T extends any[]` forces TypeScript to resolve `arr[0]` using the constraint type, returning `any`. Better approach:

```typescript
function process<T>(arr: T[]): T | undefined {
  return arr[0]; // Returns T | undefined, preserving type information
}
```

**Q6: How do you write a generic function that works with object keys?**

**Answer:** Use `keyof` constraint:

```typescript
function getProperty<T, K extends keyof T>(obj: T, key: K): T[K] {
  return obj[key];
}

const person = { name: "Alice", age: 30 };
const name = getProperty(person, "name"); // string
const age = getProperty(person, "age");   // number
```

---

### 📝 **Function Overloads**

**Q7: What's the difference between overload signatures and implementation signatures?**

**Answer:** Overload signatures define the public API (how the function can be called), while the implementation signature defines how the function actually works internally. Only overload signatures are visible to callers:

```typescript
// Overload signatures (public API)
function makeDate(timestamp: number): Date;
function makeDate(m: number, d: number, y: number): Date;

// Implementation signature (internal only)
function makeDate(mOrTimestamp: number, d?: number, y?: number): Date {
  // Implementation must handle all overload cases
}
```

**Q8: When should you use function overloads vs union types?**

**Answer:** Use union types when possible - they're more flexible:

```typescript
// ❌ Overloads are restrictive
function len(s: string): number;
function len(arr: any[]): number;
function len(x: any) { return x.length; }

// ✅ Union types are more flexible
function lenBetter(x: string | any[]): number {
  return x.length;
}

// This works with union but not overloads:
lenBetter(Math.random() > 0.5 ? "hello" : [1, 2, 3]);
```

---

### ⚙️ **Optional Parameters and Callbacks**

**Q9: What's wrong with making callback parameters optional?**

**Answer:** It creates confusion about whether the parameter will actually be provided:

```typescript
// ❌ Problematic
function forEach(arr: any[], callback: (item: any, index?: number) => void) {
  // Implementation always provides index, so why is it optional?
}

// ✅ Better - don't make it optional
function forEach(arr: any[], callback: (item: any, index: number) => void) {
  // Callers can ignore parameters they don't need
}
```

**Q10: How do default parameters affect TypeScript typing?**

**Answer:** TypeScript infers types from default values and makes parameters optional:

```typescript
function createUser(name: string, age = 18, active = true) {
  // age: number (inferred from 18)
  // active: boolean (inferred from true)
  // Both are optional due to defaults
}

createUser("Alice");           // OK - uses defaults
createUser("Bob", 25);         // OK - overrides age
createUser("Charlie", 30, false); // OK - overrides both
```

---

### 🎯 **this Context**

**Q11: How do you type the `this` context in a function?**

**Answer:** Use the `this` parameter (which doesn't count as a real parameter):

```typescript
interface User {
  name: string;
  greet(this: User): string;
}

const user: User = {
  name: "Alice",
  greet: function(this: User) {
    return `Hello, I'm ${this.name}`;
  }
};
```

**Q12: What's the difference between arrow functions and regular functions regarding `this`?**

**Answer:** Arrow functions capture lexical `this`, while regular functions have dynamic `this`:

```typescript
class Component {
  name = "MyComponent";
  
  // Regular function - 'this' depends on how it's called
  regularMethod: function() {
    return this.name; // 'this' can change
  }
  
  // Arrow function - 'this' is always the Component instance
  arrowMethod = () => {
    return this.name; // 'this' is always Component
  }
}
```

---

### 🔄 **Special Return Types**

**Q13: What's the difference between `void` and `undefined` return types?**

**Answer:** `void` means "ignore the return value" while `undefined` means "must return undefined":

```typescript
function returnsVoid(): void {
  return; // OK
  // return undefined; // Also OK
  // return "hello"; // OK in contextual typing, error in literal functions
}

function returnsUndefined(): undefined {
  return undefined; // Must explicitly return undefined
}
```

**Q14: When does a function return `never`?**

**Answer:** Functions return `never` when they never complete normally (throw errors, infinite loops, or process.exit):

```typescript
function throwError(message: string): never {
  throw new Error(message); // Never returns normally
}

function infiniteLoop(): never {
  while (true) {} // Never completes
}
```

---

### 📦 **Rest Parameters and Spread**

**Q15: How do you handle the TypeScript spread argument error with arrays?**

**Answer:** TypeScript requires tuple types or const assertions for spread arguments:

```typescript
const args = [8, 5];
// Math.atan2(...args); // ❌ Error

// Solutions:
const args1 = [8, 5] as const;        // Const assertion
Math.atan2(...args1); // ✅ OK

const args2: [number, number] = [8, 5]; // Tuple type
Math.atan2(...args2); // ✅ OK
```

**Q16: How do you type rest parameters with different possible argument patterns?**

**Answer:** Use tuple union types:

```typescript
function processData(
  action: string,
  ...args: [string, number] | [string, number, boolean]
): void {
  const [name, age, active = true] = args;
  console.log(`${action}: ${name}, ${age}, active: ${active}`);
}
```

---

### 🎯 **Advanced Patterns**

**Q17: How do you create a function that preserves the exact type of its input?**

**Answer:** Use generic constraints with `as const`:

```typescript
function asConst<T extends readonly unknown[]>(arr: T): T {
  return arr;
}

const tuple = asConst([1, "hello", true] as const);
// tuple: readonly [1, "hello", true]
```

**Q18: How do you type a function that can accept any number of functions and compose them?**

**Answer:** Use recursive generic types:

```typescript
type Compose<F extends readonly Function[]> = 
  F extends readonly [(...args: any[]) => infer R]
    ? (...args: any[]) => R
    : F extends readonly [(...args: any[]) => any, ...infer Rest]
      ? Rest extends readonly Function[]
        ? Compose<Rest>
        : never
      : never;

function compose<F extends readonly Function[]>(...fns: F): Compose<F> {
  return ((...args: any[]) => 
    fns.reduceRight((result, fn) => fn(result), args[0])
  ) as Compose<F>;
}
```

---

### 💡 **Best Practices**

**Q19: What are the key principles for writing good generic functions?**

**Answer:** 
1. **Push type parameters down** - use `T[]` instead of `T extends any[]`
2. **Use fewer type parameters** - don't create unnecessary generic parameters
3. **Type parameters should appear twice** - if used only once, reconsider if generics are needed
4. **Prefer constraints over assertions** - use `extends` to limit types safely

**Q20: How do you handle function assignability with different parameter counts?**

**Answer:** Functions with fewer parameters can be assigned to functions with more parameters:

```typescript
type EventHandler = (event: Event, target: Element) => void;

// This is valid - extra parameters are ignored
const simpleHandler: EventHandler = (event) => {
  console.log(event.type);
};

// This is why array methods work:
[1, 2, 3].forEach((value, index, array) => console.log(value)); // All params
[1, 2, 3].forEach((value) => console.log(value));              // Ignore extras
```

---

## Best Practices Summary

### ✅ **Do This**
1. **Use function type expressions** for simple function types
2. **Prefer union types over overloads** when possible
3. **Use generics** to create reusable, type-safe functions
4. **Constrain generics appropriately** with `extends`
5. **Use `unknown` instead of `any`** for safer typing
6. **Leverage contextual typing** for cleaner code
7. **Use rest parameters** for variable argument functions

### ❌ **Avoid This**
1. **Don't make callback parameters optional** unless you won't provide them
2. **Don't use `Function` type** - use specific function signatures
3. **Don't overuse function overloads** - prefer union types
4. **Don't create unnecessary generic parameters**
5. **Don't use `any` return types** - use `unknown` for safety
6. **Don't ignore `this` context** in callback-heavy code

---
