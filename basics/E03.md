# TypeScript Narrowing: Mastering Type Safety Through Smart Analysis

Welcome to the world of TypeScript narrowing! This is where TypeScript truly shines - intelligently analyzing your code to provide precise type safety without sacrificing the flexibility of JavaScript. By the end of this guide, you'll understand how TypeScript narrows types and how to leverage this powerful feature for bulletproof code.

## Table of Contents
1. [What is Narrowing?](#what-is-narrowing)
2. [typeof Type Guards](#typeof-type-guards)
3. [Truthiness Narrowing](#truthiness-narrowing)
4. [Equality Narrowing](#equality-narrowing)
5. [The 'in' Operator Narrowing](#the-in-operator-narrowing)
6. [instanceof Narrowing](#instanceof-narrowing)
7. [Assignments and Control Flow](#assignments-and-control-flow)
8. [User-Defined Type Guards](#user-defined-type-guards)
9. [Discriminated Unions](#discriminated-unions)
10. [The never Type and Exhaustiveness](#the-never-type-and-exhaustiveness)
11. [Interview Questions & Answers](#interview-questions--answers)

---

## 1. What is Narrowing?

**Narrowing** is TypeScript's process of refining broad types into more specific ones based on runtime checks. It's how TypeScript understands that within certain code branches, a value must be of a more specific type than originally declared.

### The Problem: Union Types Need Refinement

```typescript
function padLeft(padding: number | string, input: string): string {
  return " ".repeat(padding) + input; // ❌ Error!
  // Argument of type 'string | number' is not assignable to parameter of type 'number'
}
```

### The Solution: Type Narrowing

```typescript
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    // TypeScript knows padding is number here
    return " ".repeat(padding) + input; // ✅ Works!
  }
  // TypeScript knows padding is string here
  return padding + input; // ✅ Works!
}
```

### How Narrowing Works

TypeScript analyzes:
- **Type guards** - Runtime checks that refine types
- **Control flow** - How code execution paths affect types
- **Assignments** - How variable assignments change types
- **Reachability** - Which code paths are possible

---

## 2. typeof Type Guards

The `typeof` operator is your first line of defense for narrowing primitive types.

### Basic typeof Narrowing

```typescript
function processValue(value: string | number | boolean) {
  if (typeof value === "string") {
    // value is definitely string here
    console.log(value.toUpperCase());
    console.log(value.length);
  } else if (typeof value === "number") {
    // value is definitely number here
    console.log(value.toFixed(2));
    console.log(value * 2);
  } else {
    // value is definitely boolean here
    console.log(value ? "Yes" : "No");
  }
}
```

### typeof Return Values

TypeScript recognizes these `typeof` return values:
- `"string"`
- `"number"`
- `"bigint"`
- `"boolean"`
- `"symbol"`
- `"undefined"`
- `"object"`
- `"function"`

### The typeof null Quirk

⚠️ **Important**: `typeof null` returns `"object"` in JavaScript!

```typescript
function printAll(strs: string | string[] | null) {
  if (typeof strs === "object") {
    // ❌ Dangerous! strs could be null
    for (const s of strs) { // Error: 'strs' is possibly 'null'
      console.log(s);
    }
  }
}

// ✅ Better approach
function printAllSafe(strs: string | string[] | null) {
  if (strs !== null && typeof strs === "object") {
    // Now strs is definitely string[]
    for (const s of strs) {
      console.log(s);
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

### Practical typeof Examples

```typescript
// API response handler
function handleApiResponse(response: string | object | null) {
  if (typeof response === "string") {
    // Handle error message
    console.error("API Error:", response);
  } else if (response !== null && typeof response === "object") {
    // Handle success data
    console.log("Data received:", response);
  } else {
    // Handle null response
    console.log("No data received");
  }
}

// Configuration parser
function parseConfig(config: string | object) {
  if (typeof config === "string") {
    // Parse JSON string
    return JSON.parse(config);
  } else {
    // Already an object
    return config;
  }
}
```

---

## 3. Truthiness Narrowing

JavaScript's truthiness behavior can be leveraged for type narrowing, but it requires careful consideration.

### Understanding Falsy Values

These values are **falsy** in JavaScript:
- `0`
- `NaN`
- `""` (empty string)
- `0n` (bigint zero)
- `null`
- `undefined`

Everything else is **truthy**.

### Basic Truthiness Narrowing

```typescript
function getUsersOnlineMessage(numUsersOnline: number) {
  if (numUsersOnline) {
    return `There are ${numUsersOnline} online now!`;
  }
  return "Nobody's here. :(";
}

// Works with union types
function processValue(value: string | null | undefined) {
  if (value) {
    // value is definitely string here (not null or undefined)
    console.log(value.toUpperCase());
  } else {
    console.log("No value provided");
  }
}
```

### Truthiness for Null/Undefined Checks

```typescript
function printAll(strs: string | string[] | null) {
  // ✅ Good: Eliminates null
  if (strs && typeof strs === "object") {
    for (const s of strs) {
      console.log(s); // strs is definitely string[]
    }
  } else if (typeof strs === "string") {
    console.log(strs);
  }
}
```

### ⚠️ Truthiness Pitfalls

```typescript
function printAll(strs: string | string[] | null) {
  // ❌ Problematic: Empty string is falsy!
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else if (typeof strs === "string") {
      console.log(strs); // Empty string "" won't reach here!
    }
  }
}

// ✅ Better: Explicit null check
function printAllCorrect(strs: string | string[] | null) {
  if (strs !== null) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else {
      console.log(strs); // Now empty strings work correctly
    }
  }
}
```

### Boolean Negation Narrowing

```typescript
function multiplyAll(
  values: number[] | undefined,
  factor: number
): number[] | undefined {
  if (!values) {
    return values; // values is undefined here
  } else {
    // values is definitely number[] here
    return values.map((x) => x * factor);
  }
}
```

### Coercing to Boolean

```typescript
// Explicit boolean conversion
Boolean("hello"); // type: boolean, value: true
!!"world";        // type: true, value: true (literal type!)

// Using in conditions
function isValidInput(input: string | null | undefined): boolean {
  return Boolean(input && input.trim());
}
```

---

## 4. Equality Narrowing

TypeScript uses equality checks (`===`, `!==`, `==`, `!=`) to narrow types intelligently.

### Strict Equality Narrowing

```typescript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // Both must be string (the only common type)
    x.toUpperCase(); // ✅ x is string
    y.toLowerCase(); // ✅ y is string
  } else {
    console.log(x); // x is string | number
    console.log(y); // y is string | boolean
  }
}
```

### Literal Value Checks

```typescript
function printAll(strs: string | string[] | null) {
  if (strs !== null) {
    if (typeof strs === "object") {
      // strs is definitely string[]
      for (const s of strs) {
        console.log(s);
      }
    } else {
      // strs is definitely string
      console.log(strs);
    }
  }
}
```

### Loose Equality for Null/Undefined

```typescript
interface Container {
  value: number | null | undefined;
}

function multiplyValue(container: Container, factor: number) {
  // == null checks for both null AND undefined
  if (container.value != null) {
    // container.value is definitely number here
    console.log(container.value);
    container.value *= factor;
  }
}

// Equivalent to:
function multiplyValueExplicit(container: Container, factor: number) {
  if (container.value !== null && container.value !== undefined) {
    console.log(container.value);
    container.value *= factor;
  }
}
```

### Switch Statement Narrowing

```typescript
type Status = "loading" | "success" | "error";

function handleStatus(status: Status) {
  switch (status) {
    case "loading":
      // status is "loading" here
      showSpinner();
      break;
    case "success":
      // status is "success" here
      showData();
      break;
    case "error":
      // status is "error" here
      showError();
      break;
  }
}
```

---

## 5. The 'in' Operator Narrowing

The `in` operator checks if a property exists on an object, making it perfect for narrowing object types.

### Basic 'in' Operator Usage

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    // animal is Fish here
    return animal.swim();
  }
  // animal is Bird here
  return animal.fly();
}
```

### Optional Properties and 'in' Operator

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  if ("swim" in animal) {
    // animal could be Fish OR Human
    animal; // Fish | Human
  } else {
    // animal could be Bird OR Human
    animal; // Bird | Human
  }
}
```

### Practical Examples

```typescript
// API response handling
interface SuccessResponse {
  data: any;
  status: "success";
}

interface ErrorResponse {
  error: string;
  status: "error";
}

function handleResponse(response: SuccessResponse | ErrorResponse) {
  if ("data" in response) {
    // response is SuccessResponse
    console.log("Success:", response.data);
  } else {
    // response is ErrorResponse
    console.log("Error:", response.error);
  }
}

// Feature detection
interface ModernBrowser {
  fetch: () => void;
  localStorage: Storage;
}

interface LegacyBrowser {
  XMLHttpRequest: any;
}

function makeRequest(browser: ModernBrowser | LegacyBrowser) {
  if ("fetch" in browser) {
    // Use modern fetch API
    browser.fetch();
  } else {
    // Use legacy XMLHttpRequest
    new browser.XMLHttpRequest();
  }
}
```

### Complex Object Narrowing

```typescript
interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Circle {
  kind: "circle";
  radius: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Rectangle | Circle | Triangle;

function calculateArea(shape: Shape) {
  if ("width" in shape) {
    // shape is Rectangle
    return shape.width * shape.height;
  } else if ("radius" in shape) {
    // shape is Circle
    return Math.PI * shape.radius ** 2;
  } else {
    // shape is Triangle
    return 0.5 * shape.base * shape.height;
  }
}
```

---

## 6. instanceof Narrowing

The `instanceof` operator checks if an object is an instance of a specific class or constructor function.

### Basic instanceof Usage

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    // x is definitely Date here
    console.log(x.toUTCString());
  } else {
    // x is definitely string here
    console.log(x.toUpperCase());
  }
}
```

### Class Instance Narrowing

```typescript
class Dog {
  bark() {
    console.log("Woof!");
  }
}

class Cat {
  meow() {
    console.log("Meow!");
  }
}

function makeSound(animal: Dog | Cat) {
  if (animal instanceof Dog) {
    animal.bark(); // animal is Dog
  } else {
    animal.meow(); // animal is Cat
  }
}
```

### Error Handling with instanceof

```typescript
async function handleApiCall() {
  try {
    const response = await fetch("/api/data");
    const data = await response.json();
    return data;
  } catch (error) {
    if (error instanceof Error) {
      // error is Error instance
      console.log("Error message:", error.message);
      console.log("Stack trace:", error.stack);
    } else {
      // error is unknown type
      console.log("Unknown error:", error);
    }
  }
}
```

### Built-in Types with instanceof

```typescript
function processInput(input: string | number | Date | Array<any>) {
  if (input instanceof Date) {
    return input.toISOString();
  } else if (input instanceof Array) {
    return input.length;
  } else if (typeof input === "string") {
    return input.toUpperCase();
  } else {
    return input * 2;
  }
}
```

### Custom Class Hierarchies

```typescript
abstract class Animal {
  abstract makeSound(): void;
}

class Dog extends Animal {
  makeSound() {
    console.log("Woof!");
  }
  
  fetch() {
    console.log("Fetching the ball!");
  }
}

class Cat extends Animal {
  makeSound() {
    console.log("Meow!");
  }
  
  climb() {
    console.log("Climbing the tree!");
  }
}

function interactWithAnimal(animal: Animal) {
  animal.makeSound(); // Available on all animals
  
  if (animal instanceof Dog) {
    animal.fetch(); // Only available on Dog
  } else if (animal instanceof Cat) {
    animal.climb(); // Only available on Cat
  }
}
```

---

## 7. Assignments and Control Flow

TypeScript tracks how assignments and control flow affect variable types throughout your code.

### Assignment Narrowing

```typescript
let x = Math.random() < 0.5 ? 10 : "hello world!";
// x: string | number

x = 1;
console.log(x); // x: number

x = "goodbye!";
console.log(x); // x: string

// ❌ This would be an error
// x = true; // Type 'boolean' is not assignable to type 'string | number'
```

### Control Flow Analysis

```typescript
function example() {
  let x: string | number | boolean;

  x = Math.random() < 0.5;
  console.log(x); // x: boolean

  if (Math.random() < 0.5) {
    x = "hello";
    console.log(x); // x: string
  } else {
    x = 100;
    console.log(x); // x: number
  }

  return x; // x: string | number (boolean eliminated by control flow)
}
```

### Unreachable Code Analysis

```typescript
function padLeft(padding: number | string, input: string) {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input;
    // TypeScript knows this return makes the rest unreachable
  }
  // TypeScript knows padding must be string here
  return padding + input;
}
```

### Complex Control Flow

```typescript
function processUser(user: { name: string; email?: string } | null) {
  if (!user) {
    return "No user";
  }
  
  // user is definitely not null here
  let message = `Hello, ${user.name}`;
  
  if (user.email) {
    // user.email is definitely string here
    message += ` (${user.email})`;
  }
  
  return message;
}
```

### Loop Control Flow

```typescript
function findFirstNumber(items: (string | number)[]): number | undefined {
  for (const item of items) {
    if (typeof item === "number") {
      return item; // item is number here
    }
    // item is string here
    console.log(`Skipping string: ${item}`);
  }
  return undefined;
}
```

---

## 8. User-Defined Type Guards

Sometimes you need more control over type narrowing than built-in operators provide. Type predicates let you create custom type guards.

### Basic Type Predicates

```typescript
interface Fish {
  swim: () => void;
}

interface Bird {
  fly: () => void;
}

// Custom type guard
function isFish(pet: Fish | Bird): pet is Fish {
  return (pet as Fish).swim !== undefined;
}

// Usage
function move(pet: Fish | Bird) {
  if (isFish(pet)) {
    pet.swim(); // pet is Fish here
  } else {
    pet.fly();  // pet is Bird here
  }
}
```

### Array Filtering with Type Guards

```typescript
const zoo: (Fish | Bird)[] = [getSmallPet(), getSmallPet(), getSmallPet()];

// Filter to get only Fish
const underWater: Fish[] = zoo.filter(isFish);

// Inline type predicate
const flyingAnimals: Bird[] = zoo.filter((pet): pet is Bird => {
  return (pet as Bird).fly !== undefined;
});
```

### Complex Type Guards

```typescript
interface User {
  id: string;
  name: string;
  email: string;
}

interface AdminUser extends User {
  permissions: string[];
  lastLogin: Date;
}

// Type guard for admin users
function isAdminUser(user: User): user is AdminUser {
  return 'permissions' in user && 'lastLogin' in user;
}

function handleUser(user: User) {
  console.log(`Hello, ${user.name}`);
  
  if (isAdminUser(user)) {
    // user is AdminUser here
    console.log(`Admin with ${user.permissions.length} permissions`);
    console.log(`Last login: ${user.lastLogin.toDateString()}`);
  }
}
```

### Type Guards for API Responses

```typescript
interface ApiSuccess<T> {
  success: true;
  data: T;
}

interface ApiError {
  success: false;
  error: string;
}

type ApiResponse<T> = ApiSuccess<T> | ApiError;

// Type guard for successful responses
function isApiSuccess<T>(response: ApiResponse<T>): response is ApiSuccess<T> {
  return response.success === true;
}

async function fetchUserData(id: string) {
  const response: ApiResponse<User> = await fetch(`/api/users/${id}`).then(r => r.json());
  
  if (isApiSuccess(response)) {
    // response.data is User here
    console.log(`User: ${response.data.name}`);
  } else {
    // response is ApiError here
    console.error(`Error: ${response.error}`);
  }
}
```

### Class-based Type Guards

```typescript
class NetworkError extends Error {
  constructor(public statusCode: number, message: string) {
    super(message);
  }
}

class ValidationError extends Error {
  constructor(public field: string, message: string) {
    super(message);
  }
}

function isNetworkError(error: Error): error is NetworkError {
  return error instanceof NetworkError;
}

function isValidationError(error: Error): error is ValidationError {
  return error instanceof ValidationError;
}

function handleError(error: Error) {
  if (isNetworkError(error)) {
    console.log(`Network error ${error.statusCode}: ${error.message}`);
  } else if (isValidationError(error)) {
    console.log(`Validation error in ${error.field}: ${error.message}`);
  } else {
    console.log(`Unknown error: ${error.message}`);
  }
}
```

---

## 9. Discriminated Unions

Discriminated unions are one of TypeScript's most powerful patterns for type-safe data modeling. They use a common property (discriminant) to distinguish between different types.

### The Problem with Optional Properties

```typescript
// ❌ Problematic approach
interface Shape {
  kind: "circle" | "square";
  radius?: number;    // Optional - could be undefined
  sideLength?: number; // Optional - could be undefined
}

function getArea(shape: Shape) {
  if (shape.kind === "circle") {
    return Math.PI * shape.radius! ** 2; // Need ! assertion - not ideal
  }
}
```

### The Solution: Discriminated Unions

```typescript
// ✅ Better approach with discriminated unions
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      // shape is Circle here - radius is guaranteed to exist
      return Math.PI * shape.radius ** 2;
    case "square":
      // shape is Square here - sideLength is guaranteed to exist
      return shape.sideLength ** 2;
  }
}
```

### Real-World Example: API Responses

```typescript
interface LoadingState {
  status: "loading";
}

interface SuccessState {
  status: "success";
  data: any;
}

interface ErrorState {
  status: "error";
  error: string;
}

type AsyncState = LoadingState | SuccessState | ErrorState;

function renderUI(state: AsyncState) {
  switch (state.status) {
    case "loading":
      return <Spinner />;
    case "success":
      return <DataDisplay data={state.data} />;
    case "error":
      return <ErrorMessage error={state.error} />;
  }
}
```

### Complex Discriminated Unions

```typescript
interface Rectangle {
  kind: "rectangle";
  width: number;
  height: number;
}

interface Circle {
  kind: "circle";
  radius: number;
}

interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Rectangle | Circle | Triangle;

function calculateArea(shape: Shape): number {
  switch (shape.kind) {
    case "rectangle":
      return shape.width * shape.height;
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "triangle":
      return 0.5 * shape.base * shape.height;
  }
}

function calculatePerimeter(shape: Shape): number {
  switch (shape.kind) {
    case "rectangle":
      return 2 * (shape.width + shape.height);
    case "circle":
      return 2 * Math.PI * shape.radius;
    case "triangle":
      // Assuming equilateral triangle for simplicity
      return 3 * shape.base;
  }
}
```

### Event System with Discriminated Unions

```typescript
interface ButtonClickEvent {
  type: "button_click";
  buttonId: string;
  timestamp: number;
}

interface FormSubmitEvent {
  type: "form_submit";
  formData: Record<string, any>;
  timestamp: number;
}

interface PageViewEvent {
  type: "page_view";
  url: string;
  referrer: string;
  timestamp: number;
}

type AnalyticsEvent = ButtonClickEvent | FormSubmitEvent | PageViewEvent;

function trackEvent(event: AnalyticsEvent) {
  switch (event.type) {
    case "button_click":
      console.log(`Button ${event.buttonId} clicked at ${event.timestamp}`);
      break;
    case "form_submit":
      console.log(`Form submitted with data:`, event.formData);
      break;
    case "page_view":
      console.log(`Page ${event.url} viewed from ${event.referrer}`);
      break;
  }
}
```

### State Management with Discriminated Unions

```typescript
interface IdleAction {
  type: "IDLE";
}

interface LoadingAction {
  type: "LOADING";
}

interface SuccessAction {
  type: "SUCCESS";
  payload: any;
}

interface ErrorAction {
  type: "ERROR";
  error: string;
}

type Action = IdleAction | LoadingAction | SuccessAction | ErrorAction;

interface State {
  status: "idle" | "loading" | "success" | "error";
  data?: any;
  error?: string;
}

function reducer(state: State, action: Action): State {
  switch (action.type) {
    case "IDLE":
      return { status: "idle" };
    case "LOADING":
      return { status: "loading" };
    case "SUCCESS":
      return { status: "success", data: action.payload };
    case "ERROR":
      return { status: "error", error: action.error };
    default:
      return state;
  }
}
```

---

## 10. The never Type and Exhaustiveness

The `never` type represents values that never occur. It's crucial for exhaustiveness checking and ensuring your code handles all possible cases.

### Understanding never

```typescript
// Function that never returns
function throwError(message: string): never {
  throw new Error(message);
}

// Function with infinite loop
function infiniteLoop(): never {
  while (true) {
    console.log("This runs forever");
  }
}
```

### Exhaustiveness Checking

```typescript
type Shape = Circle | Square;

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    default:
      // This should never be reached if all cases are handled
      const _exhaustiveCheck: never = shape;
      return _exhaustiveCheck;
  }
}
```

### Catching Missing Cases

```typescript
interface Triangle {
  kind: "triangle";
  base: number;
  height: number;
}

type Shape = Circle | Square | Triangle; // Added Triangle

function getArea(shape: Shape): number {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2;
    case "square":
      return shape.sideLength ** 2;
    // Missing triangle case!
    default:
      const _exhaustiveCheck: never = shape; // ❌ Error: Type 'Triangle' is not assignable to type 'never'
      return _exhaustiveCheck;
  }
}
```

### Practical Exhaustiveness Helper

```typescript
function assertNever(x: never): never {
  throw new Error("Unexpected object: " + x);
}

type Status = "pending" | "approved" | "rejected";

function handleStatus(status: Status) {
  switch (status) {
    case "pending":
      return "Waiting for approval";
    case "approved":
      return "Request approved";
    case "rejected":
      return "Request rejected";
    default:
      return assertNever(status); // Ensures all cases are handled
  }
}
```

### Union Narrowing to never

```typescript
function processValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
  } else if (typeof value === "number") {
    console.log(value.toFixed(2));
  } else {
    // value is never here - all possibilities eliminated
    const _exhaustiveCheck: never = value;
  }
}
```

### Advanced Exhaustiveness Patterns

```typescript
type AsyncState = 
  | { status: "idle" }
  | { status: "loading" }
  | { status: "success"; data: any }
  | { status: "error"; error: string };

function renderState(state: AsyncState): string {
  switch (state.status) {
    case "idle":
      return "Ready to start";
    case "loading":
      return "Loading...";
    case "success":
      return `Data: ${JSON.stringify(state.data)}`;
    case "error":
      return `Error: ${state.error}`;
    default:
      // Exhaustiveness check
      const _exhaustiveCheck: never = state;
      return _exhaustiveCheck;
  }
}
```

---

## Interview Questions & Answers

### 🎯 **Fundamental Narrowing Questions**

**Q1: What is type narrowing in TypeScript and why is it important?**

**Answer:** Type narrowing is TypeScript's process of refining broad union types into more specific types based on runtime checks. It's important because it allows you to safely work with union types while maintaining type safety.

```typescript
function processId(id: string | number) {
  if (typeof id === "string") {
    // TypeScript narrows id to string here
    return id.toUpperCase(); // Safe to use string methods
  } else {
    // TypeScript narrows id to number here
    return id.toFixed(2); // Safe to use number methods
  }
}
```

**Q2: What are type guards and how do they enable narrowing?**

**Answer:** Type guards are runtime checks that TypeScript recognizes as type refinements. They include `typeof`, `instanceof`, `in` operator, equality checks, and custom type predicates.

```typescript
// typeof type guard
if (typeof value === "string") { /* value is string */ }

// instanceof type guard
if (error instanceof Error) { /* error is Error */ }

// in operator type guard
if ("swim" in animal) { /* animal has swim property */ }

// Custom type predicate
function isString(value: any): value is string {
  return typeof value === "string";
}
```

---

### 🔍 **typeof Questions**

**Q3: What are the possible return values of the typeof operator in TypeScript?**

**Answer:** TypeScript recognizes these `typeof` return values:
- `"string"`, `"number"`, `"bigint"`, `"boolean"`, `"symbol"`, `"undefined"`, `"object"`, `"function"`

**Important quirk:** `typeof null` returns `"object"`, not `"null"`.

```typescript
function checkType(value: unknown) {
  console.log(typeof value);
  // null -> "object" (JavaScript quirk!)
  // undefined -> "undefined"
  // [] -> "object"
  // {} -> "object"
}
```

**Q4: How do you safely check for arrays using typeof?**

**Answer:** You can't reliably detect arrays with `typeof` alone since it returns `"object"`. Use `Array.isArray()` instead:

```typescript
function processValue(value: string | number[]) {
  if (Array.isArray(value)) {
    // value is number[] here
    return value.map(n => n * 2);
  } else {
    // value is string here
    return value.toUpperCase();
  }
}
```

---

### ✅ **Truthiness Questions**

**Q5: What values are falsy in JavaScript, and how does this affect TypeScript narrowing?**

**Answer:** Falsy values are: `0`, `NaN`, `""`, `0n`, `null`, `undefined`. TypeScript uses truthiness for narrowing:

```typescript
function processValue(value: string | null | undefined) {
  if (value) {
    // value is definitely string here (truthy)
    console.log(value.toUpperCase());
  } else {
    // value is null or undefined here
    console.log("No value provided");
  }
}
```

**Q6: What's a common pitfall with truthiness narrowing?**

**Answer:** Empty strings and zero are falsy, which can cause unexpected behavior:

```typescript
function processInput(input: string | null) {
  if (input) {
    console.log(input.toUpperCase());
  } else {
    // ❌ Problem: Empty string "" ends up here!
    console.log("No input");
  }
}

// ✅ Better: Explicit null check
function processInputSafe(input: string | null) {
  if (input !== null) {
    console.log(input.toUpperCase()); // Now "" works correctly
  }
}
```

---

### 🎯 **Equality and 'in' Operator Questions**

**Q7: How does TypeScript narrow types with equality checks?**

**Answer:** TypeScript narrows based on shared types in equality comparisons:

```typescript
function compare(x: string | number, y: string | boolean) {
  if (x === y) {
    // Both must be string (only common type)
    x.toUpperCase(); // x is string
    y.toLowerCase(); // y is string
  }
}
```

**Q8: What's the difference between `== null` and `=== null` for narrowing?**

**Answer:** `== null` checks for both `null` and `undefined`, while `=== null` only checks for `null`:

```typescript
function processValue(value: string | null | undefined) {
  if (value != null) {
    // Eliminates both null AND undefined
    console.log(value.toUpperCase()); // value is string
  }
  
  if (value !== null) {
    // Only eliminates null, undefined still possible
    console.log(value?.toUpperCase()); // value is string | undefined
  }
}
```

**Q9: How does the 'in' operator work with optional properties?**

**Answer:** The `in` operator checks for property existence, so optional properties appear in both branches:

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };
type Human = { swim?: () => void; fly?: () => void };

function move(animal: Fish | Bird | Human) {
  if ("swim" in animal) {
    // animal is Fish | Human (both have swim property)
  } else {
    // animal is Bird | Human (Human might not have swim)
  }
}
```

---

### 🏗️ **User-Defined Type Guards Questions**

**Q10: How do you create a custom type guard function?**

**Answer:** Use a type predicate with the `parameterName is Type` syntax:

```typescript
interface User {
  name: string;
}

interface AdminUser extends User {
  permissions: string[];
}

function isAdminUser(user: User): user is AdminUser {
  return 'permissions' in user;
}

// Usage
function handleUser(user: User) {
  if (isAdminUser(user)) {
    // user is AdminUser here
    console.log(user.permissions);
  }
}
```

**Q11: How do type guards work with array filtering?**

**Answer:** Type guards can filter arrays to more specific types:

```typescript
const animals: (Fish | Bird)[] = [getFish(), getBird(), getFish()];

function isFish(animal: Fish | Bird): animal is Fish {
  return 'swim' in animal;
}

const fishes: Fish[] = animals.filter(isFish); // Filtered to only Fish
```

---

### 🔄 **Discriminated Unions Questions**

**Q12: What is a discriminated union and why is it useful?**

**Answer:** A discriminated union uses a common property (discriminant) to distinguish between types, enabling safe type narrowing:

```typescript
interface Circle {
  kind: "circle";    // Discriminant property
  radius: number;
}

interface Square {
  kind: "square";    // Discriminant property
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2; // shape is Circle
    case "square":
      return shape.sideLength ** 2; // shape is Square
  }
}
```

**Q13: How do discriminated unions compare to optional properties?**

**Answer:** Discriminated unions are safer because they guarantee property existence:

```typescript
// ❌ Problematic: Optional properties
interface ShapeWithOptionals {
  kind: "circle" | "square";
  radius?: number;
  sideLength?: number;
}

// ✅ Better: Discriminated union
interface Circle { kind: "circle"; radius: number; }
interface Square { kind: "square"; sideLength: number; }
type Shape = Circle | Square;

// No need for ! assertions or undefined checks
function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2; // radius guaranteed to exist
    case "square":
      return shape.sideLength ** 2; // sideLength guaranteed to exist
  }
}
```

---

### ⚡ **Control Flow Questions**

**Q14: How does TypeScript track types through control flow?**

**Answer:** TypeScript analyzes all possible execution paths and tracks how types change:

```typescript
function example() {
  let x: string | number | boolean;

  x = Math.random() < 0.5; // x is boolean

  if (Math.random() < 0.5) {
    x = "hello"; // x is string in this branch
  } else {
    x = 100; // x is number in this branch
  }

  // x is string | number here (boolean eliminated)
  return x;
}
```

**Q15: What happens with unreachable code after type guards?**

**Answer:** TypeScript recognizes unreachable code and adjusts types accordingly:

```typescript
function processValue(value: string | number) {
  if (typeof value === "string") {
    console.log(value.toUpperCase());
    return; // Early return
  }
  
  // TypeScript knows value must be number here
  console.log(value.toFixed(2)); // No type error
}
```

---

### 🚫 **never Type Questions**

**Q16: What is the never type and when is it used?**

**Answer:** `never` represents values that never occur. It's used for:
- Functions that never return (throw errors, infinite loops)
- Exhaustiveness checking in switch statements
- Impossible states in type narrowing

```typescript
function throwError(message: string): never {
  throw new Error(message);
}

function exhaustiveCheck(value: never): never {
  throw new Error(`Unexpected value: ${value}`);
}
```

**Q17: How do you use never for exhaustiveness checking?**

**Answer:** Assign the remaining value to `never` in the default case:

```typescript
type Status = "pending" | "approved" | "rejected";

function handleStatus(status: Status) {
  switch (status) {
    case "pending":
      return "Waiting";
    case "approved":
      return "Approved";
    case "rejected":
      return "Rejected";
    default:
      const _exhaustiveCheck: never = status; // Ensures all cases handled
      return _exhaustiveCheck;
  }
}

// If you add a new status, TypeScript will error on the never assignment
```

---

### 🎯 **Advanced Questions**

**Q18: How do you handle complex nested narrowing scenarios?**

**Answer:** Combine multiple narrowing techniques and use helper functions:

```typescript
interface ApiResponse {
  success: boolean;
  data?: any;
  error?: string;
}

function isSuccessResponse(response: ApiResponse): response is ApiResponse & { success: true; data: any } {
  return response.success && response.data !== undefined;
}

function handleResponse(response: ApiResponse) {
  if (isSuccessResponse(response)) {
    // response.data is guaranteed to exist
    console.log("Success:", response.data);
  } else if (!response.success && response.error) {
    console.log("Error:", response.error);
  }
}
```

**Q19: What are assertion functions and how do they differ from type guards?**

**Answer:** Assertion functions throw errors if conditions aren't met, while type guards return boolean values:

```typescript
// Type guard - returns boolean
function isString(value: unknown): value is string {
  return typeof value === "string";
}

// Assertion function - throws if false
function assertIsString(value: unknown): asserts value is string {
  if (typeof value !== "string") {
    throw new Error("Expected string");
  }
}

// Usage
function processValue(value: unknown) {
  assertIsString(value);
  // value is definitely string after this point
  console.log(value.toUpperCase());
}
```

**Q20: How do you narrow types in generic functions?**

**Answer:** Use type guards and conditional logic within generic constraints:

```typescript
function processArray<T>(items: T[], predicate: (item: T) => item is T & { id: string }): (T & { id: string })[] {
  return items.filter(predicate);
}

// Usage
interface User { name: string; id?: string; }
interface UserWithId extends User { id: string; }

const users: User[] = [
  { name: "Alice", id: "1" },
  { name: "Bob" }
];

function hasId(user: User): user is UserWithId {
  return user.id !== undefined;
}

const usersWithId = processArray(users, hasId); // UserWithId[]
```

---

## Best Practices Summary

### ✅ **Do This**
1. **Use explicit type guards** instead of relying solely on truthiness
2. **Prefer discriminated unions** over optional properties for variant data
3. **Implement exhaustiveness checking** with `never` type
4. **Create custom type guards** for complex type checking logic
5. **Use `!= null`** to check for both null and undefined
6. **Combine multiple narrowing techniques** for complex scenarios

### ❌ **Avoid This**
1. **Don't rely on truthiness** for empty strings or zero values
2. **Don't use type assertions** when narrowing is possible
3. **Don't ignore the `typeof null === "object"` quirk**
4. **Don't forget exhaustiveness checking** in switch statements
5. **Don't mix optional properties** with discriminated unions
6. **Don't use `any`** when proper narrowing can solve the problem

---
