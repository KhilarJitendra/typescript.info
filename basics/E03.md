# TypeScript Narrowing: Essential Guide

Learn how TypeScript intelligently refines types for safer code.

## Table of Contents
1. [What is Narrowing?](#1-what-is-narrowing)
2. [typeof Type Guards](#2-typeof-type-guards)
3. [Truthiness Narrowing](#3-truthiness-narrowing)
4. [Equality Narrowing](#4-equality-narrowing)
5. [in Operator & instanceof](#5-in-operator--instanceof)
6. [Discriminated Unions](#6-discriminated-unions)
7. [Key Interview Questions](#key-interview-questions)

---

## 1. What is Narrowing?

**Narrowing** is TypeScript's process of refining broad types into more specific ones based on runtime checks.

```typescript
// Problem: Union type is too broad
function padLeft(padding: number | string, input: string): string {
  return " ".repeat(padding) + input; // ❌ Error!
}

// Solution: Type narrowing
function padLeft(padding: number | string, input: string): string {
  if (typeof padding === "number") {
    return " ".repeat(padding) + input; // ✅ padding is number
  }
  return padding + input; // ✅ padding is string
}
```

---

## 2. typeof Type Guards

Use `typeof` to narrow primitive types:

```typescript
function processValue(value: string | number | boolean) {
  if (typeof value === "string") {
    console.log(value.toUpperCase()); // value is string
  } else if (typeof value === "number") {
    console.log(value.toFixed(2));    // value is number
  } else {
    console.log(value ? "Yes" : "No"); // value is boolean
  }
}
```

### typeof Return Values
- `"string"`, `"number"`, `"boolean"`, `"undefined"`
- `"object"`, `"function"`, `"symbol"`, `"bigint"`

**⚠️ Important**: `typeof null` returns `"object"`!

```typescript
function printAll(strs: string | string[] | null) {
  if (typeof strs === "object") {
    // ❌ Dangerous! strs could be null
    for (const s of strs) { // Error: 'strs' is possibly 'null'
      console.log(s);
    }
  }
}

// ✅ Better: Check for null first
function printAllSafe(strs: string | string[] | null) {
  if (strs !== null && typeof strs === "object") {
    for (const s of strs) { // ✅ Safe
      console.log(s);
    }
  }
}
```

---

## 3. Truthiness Narrowing

JavaScript's falsy values: `0`, `NaN`, `""`, `0n`, `null`, `undefined`

```typescript
function processValue(value: string | null | undefined) {
  if (value) {
    // value is definitely string here
    console.log(value.toUpperCase());
  } else {
    console.log("No value provided");
  }
}
```

### ⚠️ Truthiness Pitfalls
```typescript
function printAll(strs: string | string[] | null) {
  if (strs) {
    if (typeof strs === "object") {
      for (const s of strs) {
        console.log(s);
      }
    } else {
      console.log(strs); // ❌ Empty string "" won't reach here!
    }
  }
}

// ✅ Better: Explicit null check
function printAllCorrect(strs: string | string[] | null) {
  if (strs !== null) {
    // Now empty strings work correctly
  }
}
```

---

## 4. Equality Narrowing

Use `===`, `!==`, `==`, `!=` to narrow types:

```typescript
function example(x: string | number, y: string | boolean) {
  if (x === y) {
    // Both must be string (only common type)
    x.toUpperCase(); // ✅ x is string
    y.toLowerCase(); // ✅ y is string
  }
}
```

### Null/Undefined Checks
```typescript
// == null checks for both null AND undefined
function processValue(value: string | null | undefined) {
  if (value != null) {
    // value is definitely string here
    console.log(value.toUpperCase());
  }
}

// Equivalent to:
if (value !== null && value !== undefined) {
  // ...
}
```

---

## 5. in Operator & instanceof

### in Operator
Check if property exists on an object:

```typescript
type Fish = { swim: () => void };
type Bird = { fly: () => void };

function move(animal: Fish | Bird) {
  if ("swim" in animal) {
    animal.swim(); // animal is Fish
  } else {
    animal.fly();  // animal is Bird
  }
}
```

### instanceof
Check if value is instance of a class:

```typescript
function logValue(x: Date | string) {
  if (x instanceof Date) {
    console.log(x.toUTCString()); // x is Date
  } else {
    console.log(x.toUpperCase()); // x is string
  }
}
```

---

## 6. Discriminated Unions

Use a common property to distinguish between types:

```typescript
// ❌ Problematic: Optional properties
interface Shape {
  kind: "circle" | "square";
  radius?: number;
  sideLength?: number;
}

// ✅ Better: Discriminated union
interface Circle {
  kind: "circle";
  radius: number;
}

interface Square {
  kind: "square";
  sideLength: number;
}

type Shape = Circle | Square;

function getArea(shape: Shape) {
  switch (shape.kind) {
    case "circle":
      return Math.PI * shape.radius ** 2; // shape is Circle
    case "square":
      return shape.sideLength ** 2;       // shape is Square
  }
}
```

### Real-World Example
```typescript
interface LoadingState {
  status: "loading";
}

interface SuccessState {
  status: "success";
  data: any;
}

interface ErrorState {
  status: "error";
  error: string;
}

type AsyncState = LoadingState | SuccessState | ErrorState;

function renderUI(state: AsyncState) {
  switch (state.status) {
    case "loading":
      return "Loading...";
    case "success":
      return `Data: ${state.data}`;
    case "error":
      return `Error: ${state.error}`;
  }
}
```

---

## Key Interview Questions

### Q1: What is type narrowing and why is it important?
**Answer:** Type narrowing is TypeScript's process of refining broad union types into more specific types based on runtime checks. It allows safe use of union types while maintaining type safety.

### Q2: What's the `typeof null` quirk?
**Answer:** `typeof null` returns `"object"` in JavaScript, not `"null"`. Always check for null explicitly:

```typescript
if (value !== null && typeof value === "object") {
  // Now safely an object, not null
}
```

### Q3: What's the difference between `==` and `===` for narrowing?
**Answer:** 
- `=== null` only checks for `null`
- `== null` checks for both `null` and `undefined`

```typescript
if (value != null) {
  // Eliminates both null AND undefined
}
```

### Q4: How do discriminated unions work?
**Answer:** Use a common property (discriminant) to distinguish between types:

```typescript
interface Success { status: "success"; data: any; }
interface Error { status: "error"; message: string; }

type Result = Success | Error;

function handle(result: Result) {
  if (result.status === "success") {
    console.log(result.data); // TypeScript knows it's Success
  } else {
    console.log(result.message); // TypeScript knows it's Error
  }
}
```

### Q5: What's the difference between `in` operator and property access?
**Answer:** 
- `in` operator checks if property exists: `"prop" in obj`
- Property access gets the value: `obj.prop`
- Use `in` for type narrowing, property access for getting values

---

## Best Practices

### ✅ Do This
1. **Use explicit type guards** instead of relying on truthiness
2. **Check for null explicitly** rather than using truthiness
3. **Use discriminated unions** for variant data types
4. **Combine multiple narrowing techniques** for complex scenarios
5. **Use `!= null`** to check for both null and undefined

### ❌ Avoid This
1. **Don't rely on truthiness** for empty strings or zero values
2. **Don't forget the `typeof null === "object"` quirk**
3. **Don't use type assertions** when narrowing is possible
4. **Don't ignore TypeScript's narrowing** - trust the type system

---

## Next Steps
- **Functions**: Type-safe function patterns with narrowing
- **Objects**: Complex object type patterns
- **Generics**: Advanced type patterns
- **Utility Types**: Built-in TypeScript helpers
