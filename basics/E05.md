# TypeScript Object Types: Mastering Structured Data with Type Safety

Objects are the fundamental building blocks of JavaScript applications, and TypeScript provides powerful tools to make them type-safe and maintainable. This comprehensive guide will teach you everything you need to know about TypeScript object types - from basic property definitions to advanced generic patterns.

## Table of Contents
1. [Basic Object Types](#basic-object-types)
2. [Property Modifiers](#property-modifiers)
3. [Index Signatures](#index-signatures)
4. [Excess Property Checks](#excess-property-checks)
5. [Extending Types](#extending-types)
6. [Intersection Types](#intersection-types)
7. [Generic Object Types](#generic-object-types)
8. [Array and ReadonlyArray Types](#array-and-readonlyarray-types)
9. [Tuple Types](#tuple-types)
10. [Advanced Object Patterns](#advanced-object-patterns)
11. [Interview Questions & Answers](#interview-questions--answers)

---

## 1. Basic Object Types

TypeScript provides three main ways to define object types: anonymous objects, interfaces, and type aliases. Each has its place in different scenarios.

### Anonymous Object Types

```typescript
// Inline object type definition
function greet(person: { name: string; age: number }) {
  return `Hello ${person.name}, you are ${person.age} years old`;
}

greet({ name: "Alice", age: 30 }); // ✅ Works
// greet({ name: "Bob" }); // ❌ Error: missing 'age' property
```

### Interface Declarations

```typescript
// Named object type using interface
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return `Hello ${person.name}, you are ${person.age} years old`;
}

// Usage
const alice: Person = { name: "Alice", age: 30 };
greet(alice);
```

### Type Aliases

```typescript
// Named object type using type alias
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return `Hello ${person.name}, you are ${person.age} years old`;
}

// Usage
const bob: Person = { name: "Bob", age: 25 };
greet(bob);
```

### When to Use Each Approach

```typescript
// ✅ Anonymous: Simple, one-off object types
function processCoordinates(point: { x: number; y: number }) {
  return Math.sqrt(point.x ** 2 + point.y ** 2);
}

// ✅ Interface: When you need extension or declaration merging
interface User {
  id: string;
  name: string;
}

interface User {
  email: string; // Declaration merging - adds email to User
}

// ✅ Type alias: For unions, primitives, or computed types
type Status = "pending" | "approved" | "rejected";
type UserWithStatus = User & { status: Status };
type UserKeys = keyof User; // "id" | "name" | "email"
```

---

## 2. Property Modifiers

TypeScript provides several modifiers to control how object properties behave: optional properties, readonly properties, and more.

### Optional Properties

```typescript
interface PaintOptions {
  shape: Shape;
  xPos?: number;    // Optional property
  yPos?: number;    // Optional property
}

function paintShape(opts: PaintOptions) {
  // All these calls are valid
}

const shape = getShape();
paintShape({ shape });                           // ✅ Only required property
paintShape({ shape, xPos: 100 });               // ✅ With xPos
paintShape({ shape, yPos: 100 });               // ✅ With yPos
paintShape({ shape, xPos: 100, yPos: 100 });    // ✅ With both
```

### Handling Optional Properties Safely

```typescript
function paintShape(opts: PaintOptions) {
  // ⚠️ Optional properties might be undefined
  let xPos = opts.xPos; // xPos: number | undefined
  let yPos = opts.yPos; // yPos: number | undefined
  
  // ✅ Safe handling with explicit checks
  let safeX = opts.xPos === undefined ? 0 : opts.xPos; // safeX: number
  let safeY = opts.yPos === undefined ? 0 : opts.yPos; // safeY: number
  
  // ✅ Even better: Use destructuring with defaults
}

// ✅ Best approach: Destructuring with default values
function paintShapeBetter({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
  console.log("x coordinate at", xPos); // xPos: number (guaranteed)
  console.log("y coordinate at", yPos); // yPos: number (guaranteed)
}
```

### Readonly Properties

```typescript
interface User {
  readonly id: string;    // Cannot be reassigned
  name: string;          // Can be modified
  readonly created: Date; // Cannot be reassigned
}

function updateUser(user: User) {
  // ✅ Can read readonly properties
  console.log(`User ID: ${user.id}`);
  
  // ✅ Can modify regular properties
  user.name = "New Name";
  
  // ❌ Cannot reassign readonly properties
  // user.id = "new-id"; // Error: Cannot assign to 'id'
  // user.created = new Date(); // Error: Cannot assign to 'created'
}
```

### Readonly vs Immutability

```typescript
interface Home {
  readonly resident: { name: string; age: number };
}

function visitForBirthday(home: Home) {
  // ✅ Can read and modify properties of readonly objects
  console.log(`Happy birthday ${home.resident.name}!`);
  home.resident.age++; // This works! readonly doesn't make objects immutable
  
  // ❌ But can't reassign the readonly property itself
  // home.resident = { name: "New Person", age: 25 }; // Error
}

// For true immutability, use readonly on nested properties too
interface ImmutableHome {
  readonly resident: {
    readonly name: string;
    readonly age: number;
  };
}
```

### Readonly Assignability

```typescript
interface Person {
  name: string;
  age: number;
}

interface ReadonlyPerson {
  readonly name: string;
  readonly age: number;
}

let writablePerson: Person = {
  name: "Alice",
  age: 30,
};

// ✅ Can assign mutable to readonly
let readonlyPerson: ReadonlyPerson = writablePerson;

// Changes to the original affect the readonly reference
writablePerson.age++;
console.log(readonlyPerson.age); // 31 - readonly doesn't prevent aliasing changes
```

---

## 3. Index Signatures

Index signatures allow you to describe objects with dynamic property names while maintaining type safety for the values.

### Basic Index Signatures

```typescript
// String index signature
interface StringDictionary {
  [key: string]: string;
}

const colors: StringDictionary = {
  red: "#FF0000",
  green: "#00FF00",
  blue: "#0000FF",
  // All values must be strings
};

// Number index signature
interface StringArray {
  [index: number]: string;
}

const myArray: StringArray = ["hello", "world"];
const secondItem = myArray[1]; // secondItem: string
```

### Mixed Properties with Index Signatures

```typescript
interface NumberOrStringDictionary {
  [index: string]: number | string;
  length: number;    // ✅ OK - number is assignable to number | string
  name: string;      // ✅ OK - string is assignable to number | string
}

// ❌ This would be an error:
interface BadDictionary {
  [index: string]: number;
  name: string; // Error: string not assignable to number
}
```

### Readonly Index Signatures

```typescript
interface ReadonlyStringArray {
  readonly [index: number]: string;
}

let myArray: ReadonlyStringArray = ["hello", "world"];

// ✅ Can read from the array
console.log(myArray[0]); // "hello"

// ❌ Cannot modify the array
// myArray[2] = "new"; // Error: Index signature only permits reading
```

### Practical Index Signature Examples

```typescript
// Configuration object
interface Config {
  [key: string]: string | number | boolean;
  host: string;
  port: number;
  ssl: boolean;
}

// API response with dynamic fields
interface ApiResponse {
  [key: string]: unknown;
  status: number;
  message: string;
}

// Cache implementation
interface Cache<T> {
  [key: string]: T;
}

const userCache: Cache<User> = {
  "user1": { id: "1", name: "Alice" },
  "user2": { id: "2", name: "Bob" },
};
```

---

## 4. Excess Property Checks

TypeScript performs excess property checking on object literals to catch common typos and mistakes.

### Understanding Excess Property Checks

```typescript
interface SquareConfig {
  color?: string;
  width?: number;
}

function createSquare(config: SquareConfig) {
  return {
    color: config.color || "red",
    area: config.width ? config.width * config.width : 20,
  };
}

// ❌ Excess property check catches typos
let mySquare = createSquare({ 
  colour: "red",  // Error: 'colour' doesn't exist, did you mean 'color'?
  width: 100 
});
```

### Bypassing Excess Property Checks

```typescript
// Method 1: Type assertion (quick but not ideal)
let mySquare1 = createSquare({ 
  width: 100, 
  opacity: 0.5 
} as SquareConfig);

// Method 2: Index signature (better for extensible objects)
interface FlexibleSquareConfig {
  color?: string;
  width?: number;
  [propName: string]: unknown; // Allow any additional properties
}

// Method 3: Assign to variable first (bypasses excess property check)
let squareOptions = { colour: "red", width: 100 };
let mySquare3 = createSquare(squareOptions); // Works if there's a common property
```

### When Excess Property Checks Apply

```typescript
interface Point {
  x: number;
  y: number;
}

// ❌ Excess property check on object literals
function processPoint(point: Point) {
  // ...
}

processPoint({ x: 1, y: 2, z: 3 }); // Error: 'z' doesn't exist

// ✅ No excess property check on variables
let point = { x: 1, y: 2, z: 3 };
processPoint(point); // OK - excess properties ignored

// ✅ No excess property check with type assertion
processPoint({ x: 1, y: 2, z: 3 } as Point); // OK
```

### Best Practices for Excess Property Checks

```typescript
// ✅ Good: Design interfaces to be extensible when needed
interface ApiOptions {
  url: string;
  method?: "GET" | "POST" | "PUT" | "DELETE";
  headers?: Record<string, string>;
  [key: string]: unknown; // Allow additional options
}

// ✅ Good: Use specific types when you want strict checking
interface StrictPoint {
  x: number;
  y: number;
  // No index signature - only x and y allowed
}

// ✅ Good: Handle configuration objects properly
interface DatabaseConfig {
  host: string;
  port: number;
  // Allow additional driver-specific options
  [key: string]: string | number | boolean | undefined;
}
```

---

## 5. Extending Types

Interface extension allows you to build new types based on existing ones, promoting code reuse and clear relationships.

### Basic Interface Extension

```typescript
interface BasicAddress {
  name?: string;
  street: string;
  city: string;
  country: string;
  postalCode: string;
}

// Extend BasicAddress with additional properties
interface AddressWithUnit extends BasicAddress {
  unit: string;
}

// Usage
const address: AddressWithUnit = {
  unit: "Apt 4B",
  street: "123 Main St",
  city: "New York",
  country: "USA",
  postalCode: "10001"
};
```

### Multiple Interface Extension

```typescript
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

// Extend from multiple interfaces
interface ColorfulCircle extends Colorful, Circle {
  // Inherits both color and radius
}

const cc: ColorfulCircle = {
  color: "red",
  radius: 42,
};

// Can also add additional properties
interface ColorfulCircleWithBorder extends Colorful, Circle {
  borderWidth: number;
  borderStyle: "solid" | "dashed" | "dotted";
}
```

### Overriding Properties in Extensions

```typescript
interface Animal {
  name: string;
  age: number;
}

// Override property with more specific type
interface Dog extends Animal {
  name: string; // Same type - OK
  breed: string;
}

// ❌ This would be an error - can't override with incompatible type
interface BadDog extends Animal {
  // name: number; // Error: incompatible with string
}

// ✅ Can override with more specific type
interface Pet extends Animal {
  name: string; // More specific than string (same in this case)
  owner: string;
}
```

### Complex Extension Hierarchies

```typescript
// Base interface
interface Entity {
  id: string;
  createdAt: Date;
  updatedAt: Date;
}

// First level extension
interface User extends Entity {
  email: string;
  name: string;
}

// Second level extension
interface AdminUser extends User {
  permissions: string[];
  lastLogin?: Date;
}

// Third level extension
interface SuperAdminUser extends AdminUser {
  canDeleteUsers: boolean;
  systemAccess: boolean;
}

// Usage
const superAdmin: SuperAdminUser = {
  // Entity properties
  id: "admin-1",
  createdAt: new Date(),
  updatedAt: new Date(),
  
  // User properties
  email: "admin@company.com",
  name: "Super Admin",
  
  // AdminUser properties
  permissions: ["read", "write", "delete"],
  lastLogin: new Date(),
  
  // SuperAdminUser properties
  canDeleteUsers: true,
  systemAccess: true,
};
```

---

## 6. Intersection Types

Intersection types combine multiple types into one, requiring the resulting type to have all properties from all intersected types.

### Basic Intersection Types

```typescript
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

// Intersection type using &
type ColorfulCircle = Colorful & Circle;

function draw(circle: ColorfulCircle) {
  console.log(`Color: ${circle.color}`);   // From Colorful
  console.log(`Radius: ${circle.radius}`); // From Circle
}

// Usage
draw({ color: "blue", radius: 42 }); // Must have both properties
```

### Interface Extension vs Intersection Types

```typescript
// Using interface extension
interface ExtendedPerson extends Person {
  email: string;
}

// Using intersection types
type IntersectedPerson = Person & {
  email: string;
};

// Both are functionally similar for object types
const person1: ExtendedPerson = {
  name: "Alice",
  age: 30,
  email: "alice@example.com"
};

const person2: IntersectedPerson = {
  name: "Bob", 
  age: 25,
  email: "bob@example.com"
};
```

### Intersection Type Conflicts

```typescript
interface Person1 {
  name: string;
}

interface Person2 {
  name: number; // Different type for same property
}

// This creates a never type for the name property
type ConflictedPerson = Person1 & Person2;

declare const person: ConflictedPerson;
person.name; // Type: never (impossible to satisfy both string and number)

// ✅ Better: Use union types for conflicting properties
interface FlexiblePerson {
  name: string | number;
}
```

### Practical Intersection Examples

```typescript
// Mixing behavior interfaces
interface Flyable {
  fly(): void;
  altitude: number;
}

interface Swimmable {
  swim(): void;
  depth: number;
}

// Duck can both fly and swim
type Duck = Flyable & Swimmable;

const duck: Duck = {
  fly() { console.log("Flying!"); },
  swim() { console.log("Swimming!"); },
  altitude: 100,
  depth: 5,
};

// API response mixing
interface BaseResponse {
  status: number;
  timestamp: Date;
}

interface UserData {
  user: {
    id: string;
    name: string;
  };
}

interface ErrorData {
  error: {
    code: string;
    message: string;
  };
}

type UserResponse = BaseResponse & UserData;
type ErrorResponse = BaseResponse & ErrorData;
```

### Advanced Intersection Patterns

```typescript
// Conditional properties with intersections
type WithId<T> = T & { id: string };
type WithTimestamp<T> = T & { timestamp: Date };
type WithBoth<T> = WithId<WithTimestamp<T>>;

interface User {
  name: string;
  email: string;
}

type UserWithId = WithId<User>;
type UserWithTimestamp = WithTimestamp<User>;
type UserWithBoth = WithBoth<User>;

// Mixin pattern
type Constructor<T = {}> = new (...args: any[]) => T;

function Timestamped<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    timestamp = Date.now();
  };
}

function Activatable<TBase extends Constructor>(Base: TBase) {
  return class extends Base {
    isActivated = false;
    activate() { this.isActivated = true; }
  };
}

// Combine mixins
class User {
  constructor(public name: string) {}
}

const TimestampedUser = Timestamped(User);
const ActivatableUser = Activatable(User);
const TimestampedActivatableUser = Timestamped(Activatable(User));
```

---

## 7. Generic Object Types

Generic object types allow you to create reusable type definitions that work with different data types while maintaining type safety.

### Basic Generic Objects

```typescript
// Generic Box container
interface Box<T> {
  contents: T;
}

// Usage with different types
let stringBox: Box<string> = { contents: "hello" };
let numberBox: Box<number> = { contents: 42 };
let userBox: Box<User> = { contents: { name: "Alice", age: 30 } };

// Generic functions with generic objects
function setContents<T>(box: Box<T>, newContents: T): void {
  box.contents = newContents;
}

setContents(stringBox, "world");     // ✅ string to string
setContents(numberBox, 100);         // ✅ number to number
// setContents(stringBox, 42);       // ❌ Error: number not assignable to string
```

### Generic Type Aliases

```typescript
// Generic type aliases for common patterns
type Result<T, E = Error> = {
  success: boolean;
  data?: T;
  error?: E;
};

type ApiResponse<T> = Result<T, { code: number; message: string }>;

// Usage
const userResult: ApiResponse<User> = {
  success: true,
  data: { name: "Alice", age: 30 }
};

const errorResult: ApiResponse<User> = {
  success: false,
  error: { code: 404, message: "User not found" }
};
```

### Multiple Generic Parameters

```typescript
// Generic key-value store
interface KeyValueStore<K, V> {
  get(key: K): V | undefined;
  set(key: K, value: V): void;
  has(key: K): boolean;
  delete(key: K): boolean;
}

// Implementation
class MapStore<K, V> implements KeyValueStore<K, V> {
  private store = new Map<K, V>();
  
  get(key: K): V | undefined {
    return this.store.get(key);
  }
  
  set(key: K, value: V): void {
    this.store.set(key, value);
  }
  
  has(key: K): boolean {
    return this.store.has(key);
  }
  
  delete(key: K): boolean {
    return this.store.delete(key);
  }
}

// Usage
const userStore = new MapStore<string, User>();
userStore.set("alice", { name: "Alice", age: 30 });
const alice = userStore.get("alice"); // alice: User | undefined
```

### Generic Constraints in Objects

```typescript
// Constrain generic types
interface Lengthwise {
  length: number;
}

interface Container<T extends Lengthwise> {
  items: T;
  count: number;
}

// ✅ These work - they have length property
const stringContainer: Container<string> = {
  items: "hello",
  count: 5
};

const arrayContainer: Container<number[]> = {
  items: [1, 2, 3],
  count: 3
};

// ❌ This doesn't work - number doesn't have length
// const numberContainer: Container<number> = {
//   items: 42,
//   count: 1
// };
```

### Advanced Generic Object Patterns

```typescript
// Generic repository pattern
interface Repository<T, ID = string> {
  findById(id: ID): Promise<T | null>;
  findAll(): Promise<T[]>;
  create(entity: Omit<T, 'id'>): Promise<T>;
  update(id: ID, updates: Partial<T>): Promise<T>;
  delete(id: ID): Promise<boolean>;
}

// Event emitter pattern
interface EventMap {
  [event: string]: any[];
}

interface EventEmitter<T extends EventMap> {
  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
  emit<K extends keyof T>(event: K, ...args: T[K]): void;
  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
}

// Usage
interface MyEvents extends EventMap {
  'user:created': [User];
  'user:updated': [User, Partial<User>];
  'error': [Error];
}

declare const emitter: EventEmitter<MyEvents>;

emitter.on('user:created', (user) => {
  // user is typed as User
  console.log(`User created: ${user.name}`);
});

emitter.emit('user:created', { name: "Alice", age: 30 });
```

---

## 8. Array and ReadonlyArray Types

Arrays are generic object types in TypeScript, with special syntax and behavior for working with collections.

### Array Type Syntax

```typescript
// Multiple ways to define array types
let numbers1: number[] = [1, 2, 3];
let numbers2: Array<number> = [1, 2, 3];

// Both are equivalent, but number[] is more common
let strings: string[] = ["hello", "world"];
let users: User[] = [
  { name: "Alice", age: 30 },
  { name: "Bob", age: 25 }
];

// Generic array functions
function processArray<T>(items: T[]): T[] {
  return items.map(item => item); // Identity function
}

const processedNumbers = processArray([1, 2, 3]); // number[]
const processedStrings = processArray(["a", "b"]); // string[]
```

### Array Methods and Type Safety

```typescript
const numbers = [1, 2, 3, 4, 5];

// Array methods maintain type safety
const doubled = numbers.map(n => n * 2);        // number[]
const strings = numbers.map(n => n.toString()); // string[]
const evens = numbers.filter(n => n % 2 === 0); // number[]
const sum = numbers.reduce((a, b) => a + b, 0);  // number

// Type-safe array destructuring
const [first, second, ...rest] = numbers;
// first: number, second: number, rest: number[]
```

### ReadonlyArray Type

```typescript
// ReadonlyArray prevents mutations
function processData(values: ReadonlyArray<string>) {
  // ✅ Can read from the array
  const copy = values.slice();
  console.log(`First value: ${values[0]}`);
  
  // ❌ Cannot mutate the array
  // values.push("hello"); // Error: Property 'push' does not exist
  // values[0] = "new";    // Error: Index signature only permits reading
}

// Shorthand syntax
function processDataShort(values: readonly string[]) {
  // Same behavior as ReadonlyArray<string>
}

// Regular arrays can be assigned to readonly arrays
const mutableArray: string[] = ["a", "b", "c"];
const readonlyArray: readonly string[] = mutableArray; // ✅ OK

// But not the reverse
const anotherMutable: string[] = readonlyArray; // ❌ Error
```

### Array vs ReadonlyArray Assignability

```typescript
// Assignability rules
let mutable: string[] = ["a", "b", "c"];
let immutable: readonly string[] = ["x", "y", "z"];

// ✅ Can assign mutable to readonly
immutable = mutable;

// ❌ Cannot assign readonly to mutable
// mutable = immutable; // Error: readonly cannot be assigned to mutable

// Function parameter design
function safeFunctionRead(items: readonly string[]) {
  // Promises not to modify the array
  return items.length;
}

function unsafeFunctionWrite(items: string[]) {
  // Might modify the array
  items.push("new item");
  return items.length;
}

// Both functions can be called with mutable arrays
const myArray = ["a", "b"];
safeFunctionRead(myArray);   // ✅ OK
unsafeFunctionWrite(myArray); // ✅ OK

// Only safe function can be called with readonly arrays
const myReadonlyArray: readonly string[] = ["a", "b"];
safeFunctionRead(myReadonlyArray);   // ✅ OK
// unsafeFunctionWrite(myReadonlyArray); // ❌ Error
```

### Modern JavaScript Collections

```typescript
// TypeScript supports other generic collections
const userMap = new Map<string, User>();
userMap.set("alice", { name: "Alice", age: 30 });
const alice = userMap.get("alice"); // User | undefined

const uniqueIds = new Set<string>();
uniqueIds.add("user-1");
uniqueIds.add("user-2");

const userPromise = new Promise<User>((resolve) => {
  resolve({ name: "Alice", age: 30 });
});

// These all work with TypeScript's type system
async function processUser() {
  const user = await userPromise; // user: User
  console.log(user.name);
}
```

---

## 9. Tuple Types

Tuples are arrays with fixed lengths and specific types at each position, perfect for representing structured data.

### Basic Tuple Types

```typescript
// Tuple type definition
type StringNumberPair = [string, number];

function processCoordinates(pair: [string, number]) {
  const name = pair[0];  // name: string
  const value = pair[1]; // value: number
  
  // ❌ Error: Tuple has no element at index 2
  // const invalid = pair[2];
}

processCoordinates(["x-axis", 10]); // ✅ OK
// processCoordinates(["x-axis"]);  // ❌ Error: missing second element
```

### Tuple Destructuring

```typescript
function processPoint(point: [number, number]) {
  // Array destructuring works with tuples
  const [x, y] = point;
  
  console.log(`Point at (${x}, ${y})`);
  // x: number, y: number
}

// Named destructuring for clarity
function processNamedPoint([x, y]: [number, number]) {
  return { x, y };
}

// Rest destructuring
function processNumbers([first, second, ...rest]: [number, number, ...number[]]) {
  console.log(`First: ${first}, Second: ${second}`);
  console.log(`Rest: ${rest.join(", ")}`);
}

processNumbers([1, 2, 3, 4, 5]);
// First: 1, Second: 2
// Rest: 3, 4, 5
```

### Optional Tuple Elements

```typescript
// Optional elements (must be at the end)
type Coordinates2dOr3d = [number, number, number?];

function setCoordinate(coord: Coordinates2dOr3d) {
  const [x, y, z] = coord;
  // x: number, y: number, z: number | undefined
  
  console.log(`2D: (${x}, ${y})`);
  if (z !== undefined) {
    console.log(`3D: (${x}, ${y}, ${z})`);
  }
  
  // Length is 2 or 3
  console.log(`Dimensions: ${coord.length}`); // coord.length: 2 | 3
}

setCoordinate([10, 20]);     // ✅ 2D coordinates
setCoordinate([10, 20, 30]); // ✅ 3D coordinates
```

### Rest Elements in Tuples

```typescript
// Rest elements for variable-length tuples
type StringNumberBooleans = [string, number, ...boolean[]];
type StringBooleansNumber = [string, ...boolean[], number];
type BooleansStringNumber = [...boolean[], string, number];

// Examples
const example1: StringNumberBooleans = ["hello", 1];
const example2: StringNumberBooleans = ["world", 2, true, false];
const example3: StringNumberBooleans = ["test", 3, true, false, true, false];

// Function parameters with rest tuples
function readButtonInput(...args: [string, number, ...boolean[]]) {
  const [name, version, ...input] = args;
  console.log(`Button ${name} v${version}, inputs: ${input.join(", ")}`);
}

// Equivalent to:
function readButtonInputEquivalent(name: string, version: number, ...input: boolean[]) {
  console.log(`Button ${name} v${version}, inputs: ${input.join(", ")}`);
}
```

### Readonly Tuples

```typescript
// Readonly tuple types
function processReadonlyPair(pair: readonly [string, number]) {
  const [name, value] = pair; // ✅ Can read
  
  // ❌ Cannot modify
  // pair[0] = "new name"; // Error: Cannot assign to read-only property
}

// const assertions create readonly tuples
let point = [3, 4] as const; // point: readonly [3, 4]

function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

// ❌ Error: readonly tuple not assignable to mutable tuple
// distanceFromOrigin(point);

// ✅ Solutions:
// 1. Make function accept readonly tuple
function distanceFromOriginSafe([x, y]: readonly [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

distanceFromOriginSafe(point); // ✅ Works

// 2. Use spread operator
distanceFromOrigin([...point]); // ✅ Creates new mutable array
```

### Advanced Tuple Patterns

```typescript
// Tuple as function parameters
type EventHandler<T extends readonly unknown[]> = (...args: T) => void;

interface EventEmitter {
  on(event: "click", handler: EventHandler<[MouseEvent]>): void;
  on(event: "keypress", handler: EventHandler<[KeyboardEvent]>): void;
  on(event: "custom", handler: EventHandler<[string, number]>): void;
}

// Tuple manipulation types
type Head<T extends readonly unknown[]> = T extends readonly [infer H, ...unknown[]] ? H : never;
type Tail<T extends readonly unknown[]> = T extends readonly [unknown, ...infer T] ? T : [];

type Example = Head<[string, number, boolean]>; // string
type ExampleTail = Tail<[string, number, boolean]>; // [number, boolean]

// Tuple to union
type TupleToUnion<T extends readonly unknown[]> = T[number];
type Colors = TupleToUnion<["red", "green", "blue"]>; // "red" | "green" | "blue"
```

---

## 10. Advanced Object Patterns

Let's explore some advanced patterns and techniques for working with object types in TypeScript.

### Mapped Types

```typescript
// Make all properties optional
type Partial<T> = {
  [P in keyof T]?: T[P];
};

// Make all properties required
type Required<T> = {
  [P in keyof T]-?: T[P];
};

// Make all properties readonly
type Readonly<T> = {
  readonly [P in keyof T]: T[P];
};

// Usage
interface User {
  id: string;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;     // All properties optional
type RequiredUser = Required<User>;   // All properties required
type ReadonlyUser = Readonly<User>;   // All properties readonly
```

### Utility Types for Objects

```typescript
// Pick specific properties
type UserSummary = Pick<User, "name" | "email">;
// { name: string; email: string; }

// Omit specific properties
type UserWithoutId = Omit<User, "id">;
// { name: string; email: string; }

// Record type for key-value pairs
type UserRoles = Record<string, "admin" | "user" | "guest">;
// { [key: string]: "admin" | "user" | "guest"; }

// Extract keys of a certain type
type StringKeys<T> = {
  [K in keyof T]: T[K] extends string ? K : never;
}[keyof T];

type UserStringKeys = StringKeys<User>; // "name" | "email"
```

### Conditional Types with Objects

```typescript
// Conditional property types
type NonNullable<T> = T extends null | undefined ? never : T;

type ApiResponse<T> = {
  data: NonNullable<T>;
  error: T extends null ? string : never;
};

// Deep readonly
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface NestedUser {
  id: string;
  profile: {
    name: string;
    settings: {
      theme: string;
      notifications: boolean;
    };
  };
}

type DeepReadonlyUser = DeepReadonly<NestedUser>;
// All nested properties are readonly
```

### Template Literal Types

```typescript
// Template literal types for object keys
type EventName<T extends string> = `on${Capitalize<T>}`;

type ButtonEvents = EventName<"click" | "hover" | "focus">;
// "onClick" | "onHover" | "onFocus"

// Dynamic object types
type EventHandlers<T extends Record<string, unknown>> = {
  [K in keyof T as EventName<string & K>]: (event: T[K]) => void;
};

type ButtonHandlers = EventHandlers<{
  click: MouseEvent;
  hover: MouseEvent;
  focus: FocusEvent;
}>;
// {
//   onClick: (event: MouseEvent) => void;
//   onHover: (event: MouseEvent) => void;
//   onFocus: (event: FocusEvent) => void;
// }
```

### Builder Pattern

```typescript
// Fluent builder pattern
class UserBuilder {
  private user: Partial<User> = {};
  
  setName(name: string): this {
    this.user.name = name;
    return this;
  }
  
  setEmail(email: string): this {
    this.user.email = email;
    return this;
  }
  
  setId(id: string): this {
    this.user.id = id;
    return this;
  }
  
  build(): User {
    if (!this.user.id || !this.user.name || !this.user.email) {
      throw new Error("Missing required fields");
    }
    return this.user as User;
  }
}

// Usage
const user = new UserBuilder()
  .setId("1")
  .setName("Alice")
  .setEmail("alice@example.com")
  .build();
```

---

## Interview Questions & Answers

### 🎯 **Basic Object Types**

**Q1: What are the three ways to define object types in TypeScript, and when would you use each?**

**Answer:** 
1. **Anonymous objects**: For simple, one-off types in function parameters
2. **Interfaces**: When you need extension, declaration merging, or defining contracts
3. **Type aliases**: For unions, computed types, or when you need more flexibility

```typescript
// Anonymous - simple, one-off use
function process(data: { id: string; value: number }) { }

// Interface - extensible, can be implemented
interface User {
  name: string;
  email: string;
}

// Type alias - flexible, can represent unions
type Status = "pending" | "approved" | "rejected";
type UserWithStatus = User & { status: Status };
```

**Q2: What's the difference between optional properties and properties with undefined values?**

**Answer:** Optional properties can be omitted entirely, while properties with `undefined` values must be present but can have the value `undefined`:

```typescript
interface OptionalProp {
  name?: string; // Can be omitted
}

interface UndefinedProp {
  name: string | undefined; // Must be present, but can be undefined
}

const obj1: OptionalProp = {}; // ✅ OK - name is optional
const obj2: UndefinedProp = { name: undefined }; // ✅ Must include name
// const obj3: UndefinedProp = {}; // ❌ Error - name is required
```

---

### 🔒 **Property Modifiers**

**Q3: What does the readonly modifier do, and what are its limitations?**

**Answer:** `readonly` prevents reassignment of the property itself, but doesn't make the value immutable:

```typescript
interface User {
  readonly id: string;
  readonly profile: { name: string; age: number };
}

const user: User = {
  id: "1",
  profile: { name: "Alice", age: 30 }
};

// user.id = "2"; // ❌ Error - cannot reassign readonly property
user.profile.age = 31; // ✅ OK - can modify properties of readonly objects
```

**Q4: How do you handle optional properties safely in function parameters?**

**Answer:** Use destructuring with default values or explicit undefined checks:

```typescript
// ✅ Best: Destructuring with defaults
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
  // xPos and yPos are guaranteed to be numbers
}

// ✅ Good: Explicit checks
function paintShapeAlt(opts: PaintOptions) {
  const xPos = opts.xPos ?? 0;
  const yPos = opts.yPos ?? 0;
}
```

---

### 📝 **Index Signatures**

**Q5: When would you use index signatures, and what are their limitations?**

**Answer:** Index signatures are useful for objects with dynamic keys but known value types. They enforce that all properties match the signature type:

```typescript
interface StringDictionary {
  [key: string]: string;
  length: number; // ❌ Error - number not assignable to string
}

// ✅ Better: Use union types
interface FlexibleDictionary {
  [key: string]: string | number;
  length: number; // ✅ OK
}
```

**Q6: How do readonly index signatures work?**

**Answer:** Readonly index signatures prevent assignment to indexed properties:

```typescript
interface ReadonlyDict {
  readonly [key: string]: string;
}

const dict: ReadonlyDict = { name: "Alice" };
console.log(dict.name); // ✅ Can read
// dict.name = "Bob";   // ❌ Cannot assign - readonly
```

---

### ⚠️ **Excess Property Checks**

**Q7: What are excess property checks and how can you work around them?**

**Answer:** Excess property checks catch typos in object literals. Workarounds include:

```typescript
interface Config {
  color?: string;
  width?: number;
}

// ❌ Excess property check
// createSquare({ colour: "red", width: 100 }); // Error: 'colour' doesn't exist

// ✅ Workarounds:
// 1. Type assertion
createSquare({ colour: "red", width: 100 } as Config);

// 2. Index signature
interface FlexibleConfig {
  color?: string;
  width?: number;
  [key: string]: unknown;
}

// 3. Assign to variable first
const options = { colour: "red", width: 100 };
createSquare(options); // OK if there's a common property
```

**Q8: When do excess property checks apply?**

**Answer:** Only on object literals directly passed to functions or assigned to variables:

```typescript
interface Point { x: number; y: number; }

// ❌ Excess property check applies
processPoint({ x: 1, y: 2, z: 3 }); // Error

// ✅ No excess property check on variables
const point = { x: 1, y: 2, z: 3 };
processPoint(point); // OK - excess properties ignored
```

---

### 🔗 **Extension and Intersection**

**Q9: What's the difference between interface extension and intersection types?**

**Answer:** Interface extension creates a new interface, while intersection combines types. They handle conflicts differently:

```typescript
// Interface extension
interface Base { name: string; }
interface Extended extends Base { age: number; }

// Intersection types
type Base2 = { name: string; };
type Intersected = Base2 & { age: number; };

// Conflict handling differs:
interface A { prop: string; }
interface B extends A { prop: number; } // ❌ Error - incompatible

type C = { prop: string; };
type D = C & { prop: number; }; // Creates never type for prop
```

**Q10: How do you extend from multiple interfaces?**

**Answer:** List multiple interfaces after `extends`:

```typescript
interface Flyable { fly(): void; }
interface Swimmable { swim(): void; }

interface Duck extends Flyable, Swimmable {
  quack(): void;
}

// Must implement all methods
const duck: Duck = {
  fly() { console.log("Flying"); },
  swim() { console.log("Swimming"); },
  quack() { console.log("Quacking"); }
};
```

---

### 🎁 **Generic Object Types**

**Q11: How do you create a generic object type with constraints?**

**Answer:** Use `extends` to constrain generic parameters:

```typescript
interface Lengthwise {
  length: number;
}

interface Container<T extends Lengthwise> {
  items: T;
  count: number;
}

// ✅ Works - string has length
const stringContainer: Container<string> = {
  items: "hello",
  count: 5
};

// ❌ Error - number doesn't have length
// const numberContainer: Container<number> = { ... };
```

**Q12: How do you create a generic key-value store interface?**

**Answer:** Use multiple generic parameters:

```typescript
interface KeyValueStore<K, V> {
  get(key: K): V | undefined;
  set(key: K, value: V): void;
  has(key: K): boolean;
  delete(key: K): boolean;
  keys(): K[];
  values(): V[];
}

// Usage
const userStore: KeyValueStore<string, User> = new Map();
userStore.set("alice", { name: "Alice", age: 30 });
```

---

### 📚 **Arrays and Tuples**

**Q13: What's the difference between Array<T> and readonly T[]?**

**Answer:** `Array<T>` is mutable, `readonly T[]` prevents mutations:

```typescript
function processData(data: readonly string[]) {
  console.log(data[0]); // ✅ Can read
  // data.push("new");  // ❌ Cannot mutate
}

const mutableArray: string[] = ["a", "b"];
const readonlyArray: readonly string[] = mutableArray; // ✅ OK

// const backToMutable: string[] = readonlyArray; // ❌ Error
```

**Q14: How do tuple types work with optional and rest elements?**

**Answer:** Optional elements must come at the end, rest elements can be anywhere:

```typescript
// Optional elements
type Coords = [number, number, number?]; // 2D or 3D coordinates

// Rest elements
type StringNumbers = [string, ...number[]]; // String followed by any number of numbers
type NumbersString = [...number[], string]; // Any number of numbers followed by string

function process(...args: [string, number, ...boolean[]]) {
  const [name, count, ...flags] = args;
  // name: string, count: number, flags: boolean[]
}
```

---

### 🚀 **Advanced Patterns**

**Q15: How do you create a type that makes all properties of an object optional?**

**Answer:** Use mapped types with the `?` modifier:

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface User {
  id: string;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// { id?: string; name?: string; email?: string; }
```

**Q16: How do you create a deep readonly type?**

**Answer:** Use recursive conditional types:

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object 
    ? DeepReadonly<T[P]> 
    : T[P];
};

interface NestedUser {
  profile: {
    settings: {
      theme: string;
    };
  };
}

type ReadonlyNestedUser = DeepReadonly<NestedUser>;
// All nested properties are readonly
```

---

### 💡 **Best Practices**

**Q17: When should you use interfaces vs type aliases for object types?**

**Answer:** 
- **Use interfaces** for object shapes that might be extended or implemented
- **Use type aliases** for unions, computed types, or when you need more flexibility

```typescript
// ✅ Interface - for extensible object contracts
interface User {
  name: string;
  email: string;
}

interface AdminUser extends User {
  permissions: string[];
}

// ✅ Type alias - for unions and computed types
type Status = "pending" | "approved" | "rejected";
type UserWithStatus = User & { status: Status };
type UserKeys = keyof User;
```

**Q18: How do you design object types for configuration objects?**

**Answer:** Use optional properties with sensible defaults and index signatures for extensibility:

```typescript
interface ApiConfig {
  baseUrl: string;
  timeout?: number;
  retries?: number;
  headers?: Record<string, string>;
  // Allow additional options
  [key: string]: unknown;
}

function createApiClient(config: ApiConfig) {
  const defaults = {
    timeout: 5000,
    retries: 3,
    headers: {},
    ...config
  };
  // ...
}
```

---

### 🎯 **Real-World Scenarios**

**Q19: How do you type a function that accepts either a single item or an array of items?**

**Answer:** Use union types and type guards:

```typescript
function processItems<T>(items: T | T[]): T[] {
  // Normalize to array
  const itemArray = Array.isArray(items) ? items : [items];
  
  return itemArray.map(item => {
    // Process each item
    return item;
  });
}

// Usage
processItems("single");           // Works with single item
processItems(["a", "b", "c"]);    // Works with array
```

**Q20: How do you create a type-safe event emitter interface?**

**Answer:** Use mapped types with template literals:

```typescript
interface EventMap {
  [event: string]: any[];
}

interface EventEmitter<T extends EventMap> {
  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
  emit<K extends keyof T>(event: K, ...args: T[K]): void;
  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
}

// Usage
interface MyEvents extends EventMap {
  'user:login': [User];
  'user:logout': [string]; // user ID
  'error': [Error];
}

const emitter: EventEmitter<MyEvents> = createEmitter();

emitter.on('user:login', (user) => {
  // user is typed as User
  console.log(`${user.name} logged in`);
});
```

---

## Best Practices Summary

### ✅ **Do This**
1. **Use interfaces for extensible object contracts**
2. **Use type aliases for unions and computed types**
3. **Prefer readonly arrays for function parameters that don't mutate**
4. **Use optional properties with default values in destructuring**
5. **Design configuration objects with index signatures for extensibility**
6. **Use tuple types for fixed-length, heterogeneous data**
7. **Leverage utility types** like `Partial`, `Pick`, and `Omit`

### ❌ **Avoid This**
1. **Don't ignore excess property check errors** - they often indicate real bugs
2. **Don't assume readonly means immutable** - it only prevents reassignment
3. **Don't overuse index signatures** - prefer specific property types when possible
4. **Don't mix mutable and readonly arrays** without understanding assignability
5. **Don't create overly complex generic constraints** - keep them simple and focused
6. **Don't use `any` in object types** - use `unknown` or specific types

---
