# TypeScript Object Types: Essential Guide

Learn the core concepts of TypeScript object types - the building blocks of type-safe JavaScript applications.

## Table of Contents

1. [Basic Object Types](#1-basic-object-types)
2. [Optional & Readonly Properties](#2-optional--readonly-properties)
3. [Extending Types](#3-extending-types)
4. [Generic Objects](#4-generic-objects)
5. [Arrays & Tuples](#5-arrays--tuples)
6. [Key Interview Questions](#key-interview-questions)

---

## 1. Basic Object Types

Three ways to define object types in TypeScript:

### Anonymous Objects

```typescript
function greet(person: { name: string; age: number }) {
  return `Hello ${person.name}`;
}
```

### Interfaces

```typescript
interface Person {
  name: string;
  age: number;
}

function greet(person: Person) {
  return `Hello ${person.name}`;
}
```

### Type Aliases

```typescript
type Person = {
  name: string;
  age: number;
};

function greet(person: Person) {
  return `Hello ${person.name}`;
}
```

**When to use:**

- **Anonymous**: Simple, one-off types
- **Interface**: When you need extension or implementation
- **Type alias**: For unions, primitives, or computed types

---

## 2. Optional & Readonly Properties

### Optional Properties

```typescript
interface PaintOptions {
  shape: Shape;
  xPos?: number; // Optional
  yPos?: number; // Optional
}

// Safe handling with defaults
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
  console.log(`Position: (${xPos}, ${yPos})`);
}
```

### Readonly Properties

```typescript
interface User {
  readonly id: string; // Cannot reassign
  name: string; // Can modify
}

function updateUser(user: User) {
  user.name = "New Name"; // ‚úÖ OK
  // user.id = "new-id";   // ‚ùå Error
}
```

**Important**: `readonly` prevents reassignment, not mutation of nested objects:

```typescript
interface Home {
  readonly resident: { name: string; age: number };
}

function visit(home: Home) {
  home.resident.age++; // ‚úÖ OK - can mutate properties
  // home.resident = {}; // ‚ùå Error - cannot reassign
}
```

---

## 3. Extending Types

### Interface Extension

```typescript
interface BasicAddress {
  street: string;
  city: string;
}

interface AddressWithUnit extends BasicAddress {
  unit: string; // Inherits street and city
}
```

### Multiple Extension

```typescript
interface Colorful {
  color: string;
}

interface Circle {
  radius: number;
}

interface ColorfulCircle extends Colorful, Circle {
  // Has both color and radius
}
```

### Intersection Types

```typescript
type ColorfulCircle = Colorful & Circle;

// Same result as interface extension for objects
```

---

## 4. Generic Objects

### Basic Generic Objects

```typescript
interface Box<T> {
  contents: T;
}

let stringBox: Box<string> = { contents: "hello" };
let numberBox: Box<number> = { contents: 42 };
```

### Generic with Constraints

```typescript
interface Lengthwise {
  length: number;
}

interface Container<T extends Lengthwise> {
  items: T;
}

// ‚úÖ Works - string has length
const stringContainer: Container<string> = { items: "hello" };

// ‚ùå Error - number doesn't have length
// const numberContainer: Container<number> = { items: 42 };
```

### Practical Example

```typescript
interface ApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

const userResponse: ApiResponse<User> = {
  success: true,
  data: { name: "Alice", age: 30 },
};
```

---

## 5. Arrays & Tuples

### Array Types

```typescript
let numbers: number[] = [1, 2, 3];
let users: User[] = [{ name: "Alice", age: 30 }];

// ReadonlyArray prevents mutations
function processData(values: readonly string[]) {
  console.log(values[0]); // ‚úÖ Can read
  // values.push("new");   // ‚ùå Cannot mutate
}
```

### Tuple Types

```typescript
// Fixed length, specific types at each position
type Point = [number, number];
type NamedPoint = [string, number, number];

function distance([x1, y1]: Point, [x2, y2]: Point): number {
  return Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
}

// Optional elements
type Coordinates = [number, number, number?]; // 2D or 3D

// Rest elements
type StringNumbers = [string, ...number[]];
```

### Readonly Tuples

```typescript
let point = [3, 4] as const; // readonly [3, 4]

function processPoint([x, y]: readonly [number, number]) {
  return x + y;
}
```

---

## Key Interview Questions

### Q1: Interface vs Type Alias - when to use which?

**Answer:**

- **Interface**: For object shapes that might be extended or implemented by classes
- **Type alias**: For unions, primitives, computed types, or when you need more flexibility

```typescript
// ‚úÖ Interface - extensible
interface User {
  name: string;
}
interface AdminUser extends User {
  permissions: string[];
}

// ‚úÖ Type alias - unions and computed types
type Status = "pending" | "approved" | "rejected";
type UserKeys = keyof User;
```

### Q2: What does `readonly` actually do?

**Answer:** Prevents reassignment of the property itself, but doesn't make nested objects immutable:

```typescript
interface Config {
  readonly settings: { theme: string };
}

const config: Config = { settings: { theme: "dark" } };
config.settings.theme = "light"; // ‚úÖ OK - can mutate
// config.settings = {};          // ‚ùå Error - cannot reassign
```

### Q3: How do you handle optional properties safely?

**Answer:** Use destructuring with defaults or explicit checks:

```typescript
// ‚úÖ Best: Destructuring with defaults
function paint({ color = "red", size = 10 }: PaintOptions) {
  // color and size are guaranteed to be defined
}

// ‚úÖ Good: Explicit checks
function paintAlt(opts: PaintOptions) {
  const color = opts.color ?? "red";
  const size = opts.size ?? 10;
}
```

### Q4: Generic constraints - how and when?

**Answer:** Use `extends` to limit what types can be used:

```typescript
// Only allow types with length property
function longest<T extends { length: number }>(a: T, b: T): T {
  return a.length >= b.length ? a : b;
}

longest("hello", "world"); // ‚úÖ strings have length
longest([1, 2], [1, 2, 3]); // ‚úÖ arrays have length
// longest(10, 20);           // ‚ùå numbers don't have length
```

### Q5: Tuple vs Array - when to use tuples?

**Answer:** Use tuples for fixed-length, heterogeneous data:

```typescript
// ‚úÖ Tuple - fixed structure
type ApiResponse = [number, string, any]; // [status, message, data]

// ‚úÖ Array - homogeneous, variable length
type UserList = User[];

// Function returning multiple values
function getCoordinates(): [number, number] {
  return [10, 20];
}

const [x, y] = getCoordinates(); // Destructuring with known types
```

---

## Best Practices

### ‚úÖ Do This

1. **Use interfaces for object contracts** that might be extended
2. **Use type aliases for unions** and computed types
3. **Prefer readonly arrays** for function parameters that don't mutate
4. **Use destructuring with defaults** for optional properties
5. **Use generic constraints** to make APIs more specific

### ‚ùå Avoid This

1. **Don't ignore excess property errors** - they catch real bugs
2. **Don't assume readonly means immutable** - it only prevents reassignment
3. **Don't overuse generics** - keep them simple and focused
4. **Don't mix mutable and readonly** without understanding assignability

---

## Next Steps

- **Classes and Inheritance**: Object-oriented programming patterns
- **Advanced Types**: Conditional types and mapped types
- **Modules**: Organizing large TypeScript applications

### üéØ **Basic Object Types**

**Q1: What are the three ways to define object types in TypeScript, and when would you use each?**

**Answer:**

1. **Anonymous objects**: For simple, one-off types in function parameters
2. **Interfaces**: When you need extension, declaration merging, or defining contracts
3. **Type aliases**: For unions, computed types, or when you need more flexibility

```typescript
// Anonymous - simple, one-off use
function process(data: { id: string; value: number }) {}

// Interface - extensible, can be implemented
interface User {
  name: string;
  email: string;
}

// Type alias - flexible, can represent unions
type Status = "pending" | "approved" | "rejected";
type UserWithStatus = User & { status: Status };
```

**Q2: What's the difference between optional properties and properties with undefined values?**

**Answer:** Optional properties can be omitted entirely, while properties with `undefined` values must be present but can have the value `undefined`:

```typescript
interface OptionalProp {
  name?: string; // Can be omitted
}

interface UndefinedProp {
  name: string | undefined; // Must be present, but can be undefined
}

const obj1: OptionalProp = {}; // ‚úÖ OK - name is optional
const obj2: UndefinedProp = { name: undefined }; // ‚úÖ Must include name
// const obj3: UndefinedProp = {}; // ‚ùå Error - name is required
```

---

### üîí **Property Modifiers**

**Q3: What does the readonly modifier do, and what are its limitations?**

**Answer:** `readonly` prevents reassignment of the property itself, but doesn't make the value immutable:

```typescript
interface User {
  readonly id: string;
  readonly profile: { name: string; age: number };
}

const user: User = {
  id: "1",
  profile: { name: "Alice", age: 30 },
};

// user.id = "2"; // ‚ùå Error - cannot reassign readonly property
user.profile.age = 31; // ‚úÖ OK - can modify properties of readonly objects
```

**Q4: How do you handle optional properties safely in function parameters?**

**Answer:** Use destructuring with default values or explicit undefined checks:

```typescript
// ‚úÖ Best: Destructuring with defaults
function paintShape({ shape, xPos = 0, yPos = 0 }: PaintOptions) {
  // xPos and yPos are guaranteed to be numbers
}

// ‚úÖ Good: Explicit checks
function paintShapeAlt(opts: PaintOptions) {
  const xPos = opts.xPos ?? 0;
  const yPos = opts.yPos ?? 0;
}
```

---

### üìù **Index Signatures**

**Q5: When would you use index signatures, and what are their limitations?**

**Answer:** Index signatures are useful for objects with dynamic keys but known value types. They enforce that all properties match the signature type:

```typescript
interface StringDictionary {
  [key: string]: string;
  length: number; // ‚ùå Error - number not assignable to string
}

// ‚úÖ Better: Use union types
interface FlexibleDictionary {
  [key: string]: string | number;
  length: number; // ‚úÖ OK
}
```

**Q6: How do readonly index signatures work?**

**Answer:** Readonly index signatures prevent assignment to indexed properties:

```typescript
interface ReadonlyDict {
  readonly [key: string]: string;
}

const dict: ReadonlyDict = { name: "Alice" };
console.log(dict.name); // ‚úÖ Can read
// dict.name = "Bob";   // ‚ùå Cannot assign - readonly
```

---

### ‚ö†Ô∏è **Excess Property Checks**

**Q7: What are excess property checks and how can you work around them?**

**Answer:** Excess property checks catch typos in object literals. Workarounds include:

```typescript
interface Config {
  color?: string;
  width?: number;
}

// ‚ùå Excess property check
// createSquare({ colour: "red", width: 100 }); // Error: 'colour' doesn't exist

// ‚úÖ Workarounds:
// 1. Type assertion
createSquare({ colour: "red", width: 100 } as Config);

// 2. Index signature
interface FlexibleConfig {
  color?: string;
  width?: number;
  [key: string]: unknown;
}

// 3. Assign to variable first
const options = { colour: "red", width: 100 };
createSquare(options); // OK if there's a common property
```

**Q8: When do excess property checks apply?**

**Answer:** Only on object literals directly passed to functions or assigned to variables:

```typescript
interface Point {
  x: number;
  y: number;
}

// ‚ùå Excess property check applies
processPoint({ x: 1, y: 2, z: 3 }); // Error

// ‚úÖ No excess property check on variables
const point = { x: 1, y: 2, z: 3 };
processPoint(point); // OK - excess properties ignored
```

---

### üîó **Extension and Intersection**

**Q9: What's the difference between interface extension and intersection types?**

**Answer:** Interface extension creates a new interface, while intersection combines types. They handle conflicts differently:

```typescript
// Interface extension
interface Base {
  name: string;
}
interface Extended extends Base {
  age: number;
}

// Intersection types
type Base2 = { name: string };
type Intersected = Base2 & { age: number };

// Conflict handling differs:
interface A {
  prop: string;
}
interface B extends A {
  prop: number;
} // ‚ùå Error - incompatible

type C = { prop: string };
type D = C & { prop: number }; // Creates never type for prop
```

**Q10: How do you extend from multiple interfaces?**

**Answer:** List multiple interfaces after `extends`:

```typescript
interface Flyable {
  fly(): void;
}
interface Swimmable {
  swim(): void;
}

interface Duck extends Flyable, Swimmable {
  quack(): void;
}

// Must implement all methods
const duck: Duck = {
  fly() {
    console.log("Flying");
  },
  swim() {
    console.log("Swimming");
  },
  quack() {
    console.log("Quacking");
  },
};
```

---

### üéÅ **Generic Object Types**

**Q11: How do you create a generic object type with constraints?**

**Answer:** Use `extends` to constrain generic parameters:

```typescript
interface Lengthwise {
  length: number;
}

interface Container<T extends Lengthwise> {
  items: T;
  count: number;
}

// ‚úÖ Works - string has length
const stringContainer: Container<string> = {
  items: "hello",
  count: 5,
};

// ‚ùå Error - number doesn't have length
// const numberContainer: Container<number> = { ... };
```

**Q12: How do you create a generic key-value store interface?**

**Answer:** Use multiple generic parameters:

```typescript
interface KeyValueStore<K, V> {
  get(key: K): V | undefined;
  set(key: K, value: V): void;
  has(key: K): boolean;
  delete(key: K): boolean;
  keys(): K[];
  values(): V[];
}

// Usage
const userStore: KeyValueStore<string, User> = new Map();
userStore.set("alice", { name: "Alice", age: 30 });
```

---

### üìö **Arrays and Tuples**

**Q13: What's the difference between Array<T> and readonly T[]?**

**Answer:** `Array<T>` is mutable, `readonly T[]` prevents mutations:

```typescript
function processData(data: readonly string[]) {
  console.log(data[0]); // ‚úÖ Can read
  // data.push("new");  // ‚ùå Cannot mutate
}

const mutableArray: string[] = ["a", "b"];
const readonlyArray: readonly string[] = mutableArray; // ‚úÖ OK

// const backToMutable: string[] = readonlyArray; // ‚ùå Error
```

**Q14: How do tuple types work with optional and rest elements?**

**Answer:** Optional elements must come at the end, rest elements can be anywhere:

```typescript
// Optional elements
type Coords = [number, number, number?]; // 2D or 3D coordinates

// Rest elements
type StringNumbers = [string, ...number[]]; // String followed by any number of numbers
type NumbersString = [...number[], string]; // Any number of numbers followed by string

function process(...args: [string, number, ...boolean[]]) {
  const [name, count, ...flags] = args;
  // name: string, count: number, flags: boolean[]
}
```

---

### üöÄ **Advanced Patterns**

**Q15: How do you create a type that makes all properties of an object optional?**

**Answer:** Use mapped types with the `?` modifier:

```typescript
type Partial<T> = {
  [P in keyof T]?: T[P];
};

interface User {
  id: string;
  name: string;
  email: string;
}

type PartialUser = Partial<User>;
// { id?: string; name?: string; email?: string; }
```

**Q16: How do you create a deep readonly type?**

**Answer:** Use recursive conditional types:

```typescript
type DeepReadonly<T> = {
  readonly [P in keyof T]: T[P] extends object ? DeepReadonly<T[P]> : T[P];
};

interface NestedUser {
  profile: {
    settings: {
      theme: string;
    };
  };
}

type ReadonlyNestedUser = DeepReadonly<NestedUser>;
// All nested properties are readonly
```

---

### üí° **Best Practices**

**Q17: When should you use interfaces vs type aliases for object types?**

**Answer:**

- **Use interfaces** for object shapes that might be extended or implemented
- **Use type aliases** for unions, computed types, or when you need more flexibility

```typescript
// ‚úÖ Interface - for extensible object contracts
interface User {
  name: string;
  email: string;
}

interface AdminUser extends User {
  permissions: string[];
}

// ‚úÖ Type alias - for unions and computed types
type Status = "pending" | "approved" | "rejected";
type UserWithStatus = User & { status: Status };
type UserKeys = keyof User;
```

**Q18: How do you design object types for configuration objects?**

**Answer:** Use optional properties with sensible defaults and index signatures for extensibility:

```typescript
interface ApiConfig {
  baseUrl: string;
  timeout?: number;
  retries?: number;
  headers?: Record<string, string>;
  // Allow additional options
  [key: string]: unknown;
}

function createApiClient(config: ApiConfig) {
  const defaults = {
    timeout: 5000,
    retries: 3,
    headers: {},
    ...config,
  };
  // ...
}
```

---

### üéØ **Real-World Scenarios**

**Q19: How do you type a function that accepts either a single item or an array of items?**

**Answer:** Use union types and type guards:

```typescript
function processItems<T>(items: T | T[]): T[] {
  // Normalize to array
  const itemArray = Array.isArray(items) ? items : [items];

  return itemArray.map((item) => {
    // Process each item
    return item;
  });
}

// Usage
processItems("single"); // Works with single item
processItems(["a", "b", "c"]); // Works with array
```

**Q20: How do you create a type-safe event emitter interface?**

**Answer:** Use mapped types with template literals:

```typescript
interface EventMap {
  [event: string]: any[];
}

interface EventEmitter<T extends EventMap> {
  on<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
  emit<K extends keyof T>(event: K, ...args: T[K]): void;
  off<K extends keyof T>(event: K, listener: (...args: T[K]) => void): void;
}

// Usage
interface MyEvents extends EventMap {
  "user:login": [User];
  "user:logout": [string]; // user ID
  error: [Error];
}

const emitter: EventEmitter<MyEvents> = createEmitter();

emitter.on("user:login", (user) => {
  // user is typed as User
  console.log(`${user.name} logged in`);
});
```

---

## Best Practices Summary

### ‚úÖ **Do This**

1. **Use interfaces for extensible object contracts**
2. **Use type aliases for unions and computed types**
3. **Prefer readonly arrays for function parameters that don't mutate**
4. **Use optional properties with default values in destructuring**
5. **Design configuration objects with index signatures for extensibility**
6. **Use tuple types for fixed-length, heterogeneous data**
7. **Leverage utility types** like `Partial`, `Pick`, and `Omit`

### ‚ùå **Avoid This**

1. **Don't ignore excess property check errors** - they often indicate real bugs
2. **Don't assume readonly means immutable** - it only prevents reassignment
3. **Don't overuse index signatures** - prefer specific property types when possible
4. **Don't mix mutable and readonly arrays** without understanding assignability
5. **Don't create overly complex generic constraints** - keep them simple and focused
6. **Don't use `any` in object types** - use `unknown` or specific types

---

## Next Steps

Now that you've mastered TypeScript object types, you're ready to explore:

- **Classes and Inheritance**: Object-oriented programming with TypeScript
- **Advanced Types**: Conditional types, mapped types, and template literals
- **Modules and Namespaces**: Organizing large-scale TypeScript applications
- **Decorators**: Adding metadata and behavior to classes and properties

Remember: Object types are the foundation of TypeScript's type system. Master these patterns, and you'll be able to model any data structure with confidence and type safety!
