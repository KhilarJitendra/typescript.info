# TypeScript Basics: Essential Guide

Learn why TypeScript matters and how to start using it effectively.

## Table of Contents

1. [Why TypeScript?](#1-why-typescript)
2. [Type Checking](#2-type-checking)
3. [Type Inference](#3-type-inference)
4. [Strict Mode](#4-strict-mode)
5. [Key Interview Questions](#key-interview-questions)

---

## 1. Why TypeScript?

**The Problem**: JavaScript finds errors at runtime when users encounter them.
**The Solution**: TypeScript finds errors at compile time during development.

```typescript
// JavaScript - crashes at runtime
const message = "Hello World";
message(); // TypeError: message is not a function

// TypeScript - error caught immediately
const message: string = "Hello World";
message(); // ❌ Error: This expression is not callable
```

**Key Benefits:**

- **Early Error Detection**: Catch bugs before they reach production
- **Better IDE Support**: Autocomplete, refactoring, navigation
- **Self-Documenting Code**: Types serve as inline documentation
- **Safer Refactoring**: Confidence when changing code

---

## 2. Type Checking

TypeScript analyzes your code structure and catches common mistakes:

```typescript
const user = {
  name: "Alice",
  age: 30,
};

// ✅ Valid - property exists
console.log(user.name.toUpperCase());

// ❌ Error - property doesn't exist
console.log(user.email); // Property 'email' does not exist

// ❌ Error - can't call number as function
user.age(); // This expression is not callable
```

**Common Errors TypeScript Catches:**

- Typos in property names
- Calling methods on `null`/`undefined`
- Wrong function argument types
- Missing object properties

---

## 3. Type Inference

TypeScript automatically figures out types when possible:

```typescript
// ✅ Inference - TypeScript knows the types
let message = "hello"; // string
let count = 42; // number
let isActive = true; // boolean
let items = [1, 2, 3]; // number[]

// ✅ Explicit - when you need to be specific
function greet(name: string): string {
  return `Hello, ${name}!`;
}
```

**Best Practice:**

- Let TypeScript infer obvious types
- Be explicit with function parameters and return types
- Use explicit types for complex objects and APIs

---

## 4. Strict Mode

Always enable strict mode for maximum type safety:

```json
// tsconfig.json
{
  "compilerOptions": {
    "strict": true
  }
}
```

### Key Strict Settings

**`noImplicitAny`** - Prevents accidental `any` types:

```typescript
// ❌ Error - parameter needs type
function process(data) {
  // Parameter 'data' implicitly has 'any' type
  return data.something;
}

// ✅ Fixed
function process(data: unknown) {
  if (typeof data === "object" && data !== null) {
    // Safe to use data here
  }
}

if true - "Be strict" - "Tell me the type or i will throw an error"
if false - "Be leninet" - "I will assume anything and won't complain" 

```

**`strictNullChecks`** - Forces null/undefined handling:

```typescript
// ❌ Error - might be null
function getLength(str: string | null) {
  return str.length; // Object is possibly 'null'
}

// ✅ Fixed
function getLength(str: string | null): number {
  return str?.length ?? 0;
}
```

---

## Key Interview Questions

### Q1: What's the main difference between JavaScript and TypeScript?

**Answer:** JavaScript uses dynamic typing (errors found at runtime), while TypeScript uses static typing (errors found at compile time).

### Q2: What is the `any` type and why avoid it?

**Answer:** `any` disables all type checking, essentially turning TypeScript back into JavaScript. It defeats the purpose of using TypeScript for type safety.

```typescript
let data: any = "hello";
data.push("world"); // No error, but will crash at runtime!

// Better alternatives:
let data: unknown = "hello"; // Forces type checking
let data: string | number = "hello"; // Specific union type
```

### Q3: What does "types are erased at compile time" mean?

**Answer:** TypeScript types don't exist in the final JavaScript output. They're only used during development for error checking and tooling.

### Q4: Why is `strictNullChecks` important?

**Answer:** It prevents the "billion-dollar mistake" by forcing explicit handling of `null` and `undefined` values, preventing common runtime errors.

### Q5: When should you use explicit types vs type inference?

**Answer:**

- **Use inference**: For obvious types like `let count = 0`
- **Use explicit types**: For function parameters, return types, and complex object structures

---

## Best Practices

### ✅ Do This

1. **Enable `"strict": true`** in tsconfig.json
2. **Let TypeScript infer obvious types**
3. **Be explicit with function signatures**
4. **Use union types instead of `any`**
5. **Handle null/undefined explicitly**

### ❌ Avoid This

1. **Don't use `any` unless absolutely necessary**
2. **Don't over-annotate obvious types**
3. **Don't ignore TypeScript errors**
4. **Don't disable strict checks without good reason**

---

## Next Steps

- **Everyday Types**: Learn about common TypeScript types
- **Type Narrowing**: Advanced type safety techniques
- **Functions**: Type-safe function patterns
- **Objects**: Structured data with TypeScript
